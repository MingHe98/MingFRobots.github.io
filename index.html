<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Resume - Start Bootstrap Theme</title>
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="#page-top">
                <span class="d-block d-lg-none">Ming He</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="assets/img/profile.jpg" alt="..." /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#about">Home</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab1">Lab 1: The Artemis board and Bluetooth</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab2">Lab 2: IMU</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab3">Lab 3: ToF</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab4">Lab 4: Motors and Open Loop Control</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab5">Lab 5: Linear PID control and Linear interpolation</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab6">Lab 6: Orientation PID control</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab7">Lab 7: Kalman Filter</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <!-- About-->
            <section class="resume-section" id="about">
                <div class="resume-section-content">
                    <h1 class="mb-0">
                        Ming He
                        <span class="text-primary"> ECE 5160 FAST ROBOTS</span>
                    </h1>
                    <div class="subheading mb-5">
                        LinkedIn: ww.linkedin.com/in/huaming-he
                        <br>
                        <a href="mailto:name@email.com">heyming98@gmail.com</a>
                    </div>
                    <p class="lead mb-5">Welcome to my Fast Robots website page.<br>I am an ECE student interested in robotics.</p>
                </div>
            </section>
            <hr class="m-0" />
            <!-- Lab 1-->
            <section class="resume-section" id="lab1">
                <div class="resume-section-content">
                    <h2 class="mb-5">LAB1: The Artemis board and Bluetooth</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Part1: Objective</h3>
                            <p>The goal of this part of the lab is to setup and become familiar with the Arduino IDE and the Artemis board. It covers skills in programming on Arduino IDE, testing board with LED blinks, communication over serial protocol, and the application of the onboard temperature sensor and Pulse Density Microphone.</p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">22nd, Jan 2024 - 7th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Blink it Up</h3>
                            <p>After successfully installing the SparkFun Apollo3 support software in the Arduino IDE and connecting the SparkFun RedBoard Artemis Nano to the laptop, I first tested programming the board by making an LED blink. In the example video below, the LED was on for 1 seconds, and then off for 1 second.</p>
                            <iframe width="auto" height="auto" src="https://www.youtube.com/embed/TP8BOoOqzuM" title="Blink LED up" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Serial Communication</h3>
                            <p>The screenshot below demonstrates how to test serial communication. In this example, the user types an input into the serial monitor, and the Artemis board reads this input and outputs it back to the serial monitor.</p>
                            <img src="Imgs_lab1/serial.jpg" alt="Serial Communication" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Analog Input Read</h3>
                            <p>The example video below demonstrates how to use the temperature sensor. The temperature recorded by the sensor on the Artemis board is sent to the serial monitor in Fahrenheit. To illustrate how the sensor responds, I covered the Artemis board with my hand, causing the temperature to increase to above 80°F.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/MeKUfqSYkI4" title="Temperature reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Microphone Usage</h3>
                            <p>The example video below demonstrates how to use the microphone on the Artemis board to detect the loudest frequency.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/gdvG9ffv2rc" title="Microphone reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) Example: Musical Tuner</h3>
                            <p>The example video below was used to identify the musical note "A". When the microphone detected an "A", corresponding to a sound frequency of approximately 526 Hz, the LED would turn on. For sounds of other frequencies, the LED remains off.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Ho1qV9jYgtg" title="Microphone reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <hr>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Part2: Objective</h3>
                            <p>The goal of part two is to establish Bluetooth communication between the computer and the Artemis board, utilizing Python in a Jupyter notebook and the Arduino programming language. This session aims to create a foundational framework for Bluetooth data transmission, setting the stage for its application in future lab exercises.</p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">22nd, Jan 2024 - 7th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Setup</h3>
                            <div class="subheading mb-3">Start Jupyter Server</div>
                            <p>After activating the virtual Python environment, I started the Jupyter server to use Jupyter notebooks for writing Python code.</p>
                            <img src="Imgs_lab1/Jupyter Lab.jpg" alt="Jupyter Lab Starts" style="width: 40vw; height: 20vw;">
                            <br>
                            <br>

                            <div class="subheading mb-3">Artemis Board Setup</div>
                            <p>After installing ArduinoBLE from the library manager in the Arduino IDE, I loaded and burned the sketch ble_arduino.ino onto the Artemis board from the ble_arduino directory in the codebase, following the instructions provided.</p>
                            <br>
                            <div class="subheading mb-3">Bluetooth Connection</div>
                            <p>After successfully setting up the Artemis board and starting the Jupyter server, the next step was to connect the Artemis board to the Python code. I first needed to read the MAC address of the Artemis board and replace the default MAC address in the Arduino code. After uploading the provided ble_arduino.ino code file to the Artemis board, the MAC address c0:89:f4:6b:86:4b was returned in the serial monitor, as shown in the figure below.</p>
                            <br>
                            <p>Since the BLEService is used in this lab, in addition to the MAC address, a UUID is also needed to identify the service. This is to differentiate the various types of data sent or received between the Artemis and the computer. Therefore, in the Jupyter Notebook, I ran the following code:
                               <br>
                               <i>from uuid import uuid4</i>
                               <br>
                               <i>uuid4()</i>
                               <br>
                               This generated a unique UUID, which I then assigned to the BLE service in both the Arduino IDE and the Jupyter notebooks.
                            </p>
                            <img src="Imgs_lab1/connection.jpg" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connection</h3>
                            <p>For the connection between the Artemis board and the computer, I first obtained the ArtemisBLEController object and connected to the Artemis Device before conducting any further tests.
                            </p>
                            <img src="Imgs_lab1/connected.png" alt="BLE connection" style="width: 40vw; height: 15w;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connection via commands</h3>
                            <p>For testing the connection between the Artemis board and the computer, some new commands were created and utilized for different tasks. When a new command type is introduced, it should be added to both the Arduino IDE and the Python code to ensure they can communicate correctly under a specific command.                                 
                            </p>

                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/cmdtypes_arduino.png" alt="command types in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/cmdtypes_python.png" alt="command types in Python" style="width: 30vw; height: 15vw;">
                            </div>
                        </div>
                    </div>    
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: ECHO Command</h3>  
                            <p>This ECHO command involved sending a string value to the Artemis board from the computer, which corresponds to the Python code. Then, the Artemis board sent back the augmented phrase, which had additional words added to the original phrase, as shown below in both the Jupyter notebooks and the Arduino IDE screenshot, to the computer.
                            </p>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/Echo_Arduino.png" alt="Echo command in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/Echo_python .png" alt="Echo command in Python" style="width: 30vw; height: 15vw;">
                            </div>

                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TIME_MILLIS Command</h3>
                            <p>The next command, GET_TIME_MILLIS, involved receiving the current time from the Artemis board by using the built-in millis() function in the Arduino IDE language. Following the instructions, I converted this value to an integer and sent it as a string to Python.
                            </p>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/millis_arduino.png" alt="Get millis in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/millis_python.png" alt="Get millis in Python" style="width: 30vw; height: 15vw;">
                            </div>
                        </div>
                    </div>              
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Notification Handler</h3>
                            <p>Instead of manually sending a command and then receiving the data, a notification handler could be used to monitor the data transfer. It is an asynchronous event handler, which means it would handle the case when the Artemis board is sending data and then receiving the data in Python.
                            <br><br>
                            The code below demonstrates how I used a notification handler to asynchronously receive the time data sent from the Artemis board.    
                            </p>
                            <img src="Imgs_lab1/event_handler.png" alt="Event handler" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TIME_MILLIS_3s Command</h3>
                            <p>The screenshot below demonstrates that I obtained the current time in milliseconds from the Artemis board and then sent it back to the laptop. After collecting these time values for 3 seconds, I was able to calculate an average speed of how fast messages can be sent. The effective data transfer rate of this method was 832 bytes/s.
                            </p>
                            <img src="Imgs_lab1/get_3s_time.png" alt="collect and send data for 3 secs" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: SEND_TIME_DATA</h3>
                            <p>Next, a new command, SEND_TIME_DATA, was introduced. In the Arduino IDE, I created a loop that, instead of sending each timestamp to the laptop, stored each timestamp in an integer array named time_stamps. By calling the command SEND_TIME_DATA, the Arduino code looped through the array and sent each data point as a string to the laptop for processing. Additionally, the data transfer rate was calculated, which was 411,000 bytes/s. This rate was in contrast to the previous method, which sent each timestamp immediately instead of storing them in an array.
                            </p>
                            <img src="Imgs_lab1/get_3s_time_inArray.png" alt="collect and send data stored in an array which collects 3 secs data" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TEMP_READINGS</h3>
                            <p>Next, as instructed, I added a second array of the same size as the time stamp array to store temperature readings. As shown in the screenshot below, each element in both arrays corresponded, meaning that the first timestamp was recorded at the same time as the first temperature reading. A command, GET_TEMP_READINGS, was introduced to loop through both arrays concurrently and send the data back to the laptop. I was able to configure the notification handler to manage the event and wrote code in Python to parse these strings, populating the data into two lists.
                            </p>
                            <img src="Imgs_lab1/get_timeTemp.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Discussion about Two methods</h3>
                            <p>The first method involves the Artemis board sending data immediately as it becomes available, without any buffering. The second approach, on the other hand, has the Artemis board buffering data into a packet before sending it to the computer. This method is faster, as indicated by the results above. The Artemis board is equipped with 384 kB of RAM, and considering that one character (char) is equivalent to 1 byte, it has the capacity to store up to 384,000 characters in its memory for transmission without running out of space.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) : Effeefctive Data Rate And Overhead</h3>
                            <p>Next, I sent messages from the computer and received replies from the Artemis board. I calculated the data rate for 5-byte replies to be about 103 bytes/s and for 120-byte replies to be 1602 bytes/s. Additionally, to understand the relationship between the number of bytes and the data transfer rate, I tested multiple byte replies at intervals of 5. It was observed that the data rate increases with the amount of bytes sent, as depicted in the graph below. This trend indicates that larger replies reduce overhead. However, as shown on the graph, when the byte replies become too large—specifically, when they exceed 80 bytes—the trend might break, and the rate might drop to a lower rate than expected.      
                            </p>
                            <img src="Imgs_lab1/effective_rate.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                            <img src="Imgs_lab1/effective_rate_graph.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) : Reliability</h3>
                            <p>By modifying the code for the command SEND_TIME_DATA to send 10 unique data points at a high speed without any delay, the reliability of the Artemis was demonstrated. In the screenshot attached below, we can see that the data is reliable by comparing the data sent from the Artemis board and the data received on the laptop.
                            </p>
                            <img src="Imgs_lab1/reliability.png" alt="reliability" style="width: 50vw; height: 25vw;">
                        </div>
                    </div>

                </div>
            </section>
            <hr class="m-0"/>
            <!-- Lab 2 -->
            <section class="resume-section" id="lab2">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB2: IMU </h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Set Up the IMU</h3>
                            <p>The goal of this part of the lab is to set up and become familiar with the IMU. It covers skills in programming on the Arduino IDE, testing the IMU with collecting accelerometer and gyroscope data.
                            </p>
                            <br>
                            <p>Given that the IMU communicates with the Artemis board using the I2C protocol, knowing the slave address is crucial. The variable AD0_VAL signifies the last bit of the IMU's I2C address, which changes depending on the ADR jumper's connection. Initially, my IMU failed to provide any data, and the connection was unsuccessful because I had AD0_VAL set to 1, whereas it should have been 0 for my device.
                            </p>
                        
                            <img src="Imgs_lab2/IMU.jpg" alt="IMU connected" style="width: 40vw; height: 20vw;">
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">7th, Feb 2024 - 14th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Visualizing IMU Accelerometer and Gyroscope Data via Serial Plotter</h3>
                            <p>The IMU was first connected to the Artemis board via the QWIIC connectors. To set up the IMU in the software, the ICM_20948 library was installed in the Arduino IDE to enable communication between the Artemis board and the IMU, allowing for data collection. The accelerometer and gyroscope data were visualized using the serial plotter.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Arvwtrr1nNU" title="visualize data on better serial plotter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Visualizing the difference between accelerometer and gyroscope data via Serial Monitor</h3>
                            <p>Based on the data printed out on the serial monitor, the accelerometer data indicates the acceleration of motion around each coordinate axis. Thus, when moving the device along each axis, it is noticeable that the corresponding accelerometer data for that axis changes rapidly. The gyroscope measures the rate of angular rotation around the spatial coordinate axes. When the device is stationary, the data remains relatively small; however, it experiences a slight drift towards larger values.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/z9GX2oCY-sw" title="visualize data on better serial plotter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">               
                            <h3 class="mb-0">Accelerometer</h3>
                            <p>In order to use the accelerometer to determine tilt and roll, we can use the atan2 function, which returns a number in radians within the range [−π,π].
                                <br>The functions used here to calculate angles are:</p>
                                <p>\(\boldsymbol{\theta = \text{atan2}(a_x , a_z )}\)</p>
                                <p>\(\boldsymbol{\phi = \text{atan2}(a_y , a_z )}\)</p>
                            <p>The screenshot provided below demonstrates the implementation of the atan2 function to calculate the angles of pitch and roll in radians, which are then converted to degrees.</p>
                            <img src="Imgs_lab2/acc_data_degree.png" alt="acc_data in degree" style="width: 40vw; height: 20vw;">
                            <p>The video below illustrates the pitch and roll data being printed out. It clearly demonstrates that the system operates effectively within the range of -90 degrees to 90 degrees along both the x and y axes, showcasing the pitch and roll actions.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/ZZJBAAaZnvM" title="accelerometer data" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <br>
                            <h4 class="mb-0">Accelerometer Accuracy</h4>
                            <p>As I record the data for a few seconds at each angle (0, -90, 90) and review the recorded data, it appears to be accurate enough. The teaching assistant instructed that there is no need to calculate the conversion factor.</p>
                            <h4 class="mb-0">Accelerometer Noise</h4>
                            <p>As demonstrated in the video below, when the device is stationary, the signal in the time domain continues to fluctuate, indicating noise that may require attention.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/5N6rgU3tApM" title="accelerometer noise" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <br>
                            <p>
                            When inspecting the noise, a fast Fourier transform (FFT)—an algorithm that computes the discrete Fourier transform (DFT) of a sequence—plays a crucial role. It is instrumental in visualizing the data more effectively in the frequency domain
                            </p>
                            <br>
                            <p>
                            When the device is completely stationary, collecting the data and applying the Fast Fourier Transform (FFT) reveals the signal in the frequency domain, as shown below.
                            </p>
                            <img src="Imgs_lab2/stationary_fft.png" alt="stationary signal in frequency domain" style="width: 50vw; height: 25vw;">
                            <p>
                            However, when a vibration occurs during the collection of accelerometer data, the signal in the frequency domain appears as illustrated in the screenshot below.
                            </p>
                            <img src="Imgs_lab2/vibration_fft.png" alt="vibrated signal in frequency domain" style="width: 50vw; height: 25vw;">
                            <p>According to the datasheet, a hardware low pass filter is implemented, which explains the relatively clean signal in the FFT diagram when the device is stationary. New signals appearing up to about 30Hz were observed when vibration was introduced. Implementing a low pass filter via software might be beneficial. Based on the diagram, I selected a cut-off frequency of 10Hz.</p>
                            <br>
                            <p>The cut-off frequency was set at 10 Hz. Using the formula \(\boldsymbol{f = \frac{1}{2\pi RC}}\), where the f is the cut-off frequency, we can solve for the RC constant. Substituting \(\boldsymbol{f = 10}\)
                               into the equation yields an RC constant of approximately 0.0159155. Consequently, using the formula \(\boldsymbol{\alpha = \frac{T}{T + RC}}\), where T is the period corresponding to the sample rate (\(\boldsymbol{T = \frac{1}{\text{sample rate}}}\)), and the sample rate is determined by recording a certain number of data points over a specific period of time, which calculates to 294.76787030213706 Hz. This results in 
                               \(\boldsymbol{T = 0.00339\, \text{seconds}}\), and therefore, \(\boldsymbol{\alpha}\) is calculated to be approximately 0.1756.
                            </p>
                            <br>
                            <p>After introducing the low pass filter, which effectively reduces the noise to some extent, the data monitoring through the serial plotter is demonstrated in the video below. The video clearly distinguishes between the raw data, represented by the blue line, and the processed data, shown as the orange line, after implementing the low pass filter. It is evident that the low pass filter significantly reduces the noise.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/T6WbZIQKHvs" title="Low pass filter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>                          
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Gyroscope</h3>
                            <p>The gyroscope measures the rate of angular change in degrees per second. To calculate the angle, it adds the product of the angular rate and time to the current angle. A key advantage of the gyroscope is its lower noise levels compared to those of the accelerometer. However, a notable drawback is data drift over time. This means that even when the device is stationary on a table and the readings should ideally be zero, the data will gradually accumulate, leading to progressively larger values as time advances.</p>
                            <br>
                            <h4 class="mb-0">Data Drift</h4>
                            <p>The video below displays data measured from the gyroscope, clearly showing how the data drifts over time even when the device is stationary.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/XjH4_3PKiMI" title="data drifts" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>                                                     
                            <h4 class="mb-0">Comparison of data output: gyroscope data versus accelerometer data and accelerometer data processed with a Low Pass Filter (LPF)</h4>
                            <p>The video below demonstrates that the gyroscope data follows the same pattern as the accelerometer data, albeit with an increasing offset over time. This growing offset highlights the drift characteristic of gyroscope data.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/EG00ankJB1E" title="data comparison between gyro and accelerometer" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>Since calculating angles from gyroscope data is heavily dependent on the time difference between each data collection, the sample rate significantly impacts accuracy. After reducing the sample rate by introducing a delay, visualization of the gyro data through the serial plotter showed that updates to the new angles became slower and noticeably less accurate.</p>
                            <h4 class="mb-0">Complimentary Filter</h4>
                            <p>Despite the application recommended by the instructor, which is capable of auto-scaling the data, not functioning on my laptop, it is still evident that after implementing the complementary filter in my system, the vibrations caused no more than a 3-degree difference.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/T3YIsY8OFpc" title="Complimentary filter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>Additionally, the working range from -90 degrees to 90 degrees was verified.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Sample Data</h3>
                            <p>I increased the speed of IMU data collection by eliminating print statements and opting to store a time value at each iteration of the while loop, and store another time value when myICM.dataReady() returns true. This resulted in an average delay of approximately 0.0005 seconds between collections. However, this delay is expected to increase with the addition of more specific function calls and filter processing. Furthermore, by comparing two arrays that store time values for the main while loop and an inner loop—which merely checks for new IMU data readiness—the pacing between them appeared consistent.</p>
                            <br>
                            <h4 class="mb-0">Discussion</h4>
                            <h5>Consider if it makes sense to have one big array, or separate arrays for storing ToF, Accelerometer, and Gyroscope data</h5>
                            <p>Storing data in separate arrays is more logical because each sensor—Time-of-Flight (ToF), Accelerometer, and Gyroscope—generates data with distinct meanings and units. Separate arrays ensure clearer organization, simplifying data processing and analysis. This is particularly important for cases like the Accelerometer, which requires the implementation of a Low Pass Filter, whereas Gyroscope data does not. Thus, processing data from different sensors may necessitate different filters or logic, indicating that using separate arrays can streamline implementation.</p>
                            <h5>Consider the best data type to store your data. Should you use string, floats, double, integers?</h5>
                            <p>For the Time-of-Flight (ToF) sensor, integers should be sufficient since distances are typically measured in whole numbers of millimeters or centimeters. However, floats are necessary if the application requires more precise distance measurements. For both the gyroscope and accelerometer, which measure different parameters, floats are adequate because they offer a good balance between precision and memory usage.</p>
                            <h5>Consider the memory of the Artemis; how much memory can you allocate to your arrays? What does that correspond to in seconds?</h5>
                            <p>Assuming I have three separate arrays for the three sensors—ToF, Gyroscope, and Accelerometer—with each sensor's reading represented as a single float, I would need 12 bytes per set of sensor readings (4 bytes × 3). Assuming the entire 384 KB of RAM is available for data storage and with a sampling rate of 100 readings per second, I can store approximately 32,000 sets of data points. This corresponds to about 320 seconds, which is equivalent to approximately 5 minutes and 20 seconds of data at a sampling rate of 100 Hz.</p>
                            <h4 class="mb-0">Demonstration of data collection for over 5 seconds</h4>
                            <p>The image below demonstrates that the board is capable of capturing data for more than 5 seconds and then transmitting it to the computer via Bluetooth.</p>
                            <img src="Imgs_lab2/5seconds data.png" alt="5s data collection" style="width: 35vw; height: 10vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Stunt Car Record</h3>
                            <p>The video below showcases the stunt car in action. I've tested its movements forward, backward, turning around, and even flipping. The car is highly sensitive and fast, making it challenging to prevent collisions with walls or to avoid flipping due to its speed.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/7lDsMkM2NdQ" title="Stunt Car" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>As the instructor clarified, there is currently no need to mount the IMU on the car for testing.</p>
                        </div>
                    </div>
            </section>

            <hr class="m-0"/>
            <!-- Lab 3 -->
            <section class="resume-section" id="lab3">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB3: Time of Flight Sensors </h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Power up your Artemis with a battery</h3>
                            <p>In constructing the project, it is essential to acquire a JST connector and a battery as primary components. The process involves carefully cutting the battery wires individually to avoid simultaneously shorting the terminals, which could result in battery damage. Subsequent steps include soldering the battery wires to the JST jumper wires, and to ensure long-term durability and safety, insulating the exposed wire sections with heat shrink over electrical tape. Additionally, verifying the wire polarity is crucial, with the positive terminal of the battery connecting to the positive terminal on the Artemis device. The final stage involves powering the Artemis without the use of the USB C port, facilitating the testing of Bluetooth Low Energy (BLE) communications between the laptop and the Artemis, thereby confirming the device's proper operational status and its ability to transmit messages wirelessly. The system powered by the battery functions as expected, which is illustrated in the picture below.
                            </p>
                            <img src="Imgs_lab3/BatPower.png" alt="the Artemis board is powered by battery" style="width: 35vw; height: 15vw;">
                            
                            <p>The video below demonstrates the successful powering of the Artemis board and the use of the 'ECHO' command to send a message to the Artemis board. I received a response from the Artemis board, confirming its operational status without the need for power from a USB C port. This indicates that I successfully got the Artemis board to work wirelessly.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/dkHCcvXffO0" title="power the artmis board by battery" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">14th, Feb 2024 - 21th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Set up the ToF sensor</h3>
                            <p>Starting by cutting one end of a QWIIC cable and removing the protective film, I then soldered the other end to the ToF sensor. After successfully installing the SparkFun VL53L1X 4m laser distance sensor library, I tested the ToF sensor by connecting it to the Artemis Board to read data from it. One challenge I encountered during this process was that it was my first time using a QWIIC connection. I needed to identify that the blue cord connected to SDA and the yellow cord connected to SCL before I started soldering the wires.</p>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">I2C Address Scanning</h3>
                            <p>There is an example sketch within the installed library that I used to scan for the I2C address of the device. The device was successfully identified, and its slave address is 0x29, as illustrated in the screenshot below.</p>
                            <img src="Imgs_lab3/I2C_address.png" alt="I2C address for ToF" style="width: 40vw; height: 20vw;">
                            <p>The I2C address matched my expectations. According to the datasheet, "The sensor's 7-bit slave address defaults to 0101001b on power-up." The I2C scanner code returned 0x29, which is accurate because 0101001b is equal to 0x29 in hexadecimal.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connect two ToF</h3>
                            <p>In this lab, two ToF sensors are used, which presents the challenge of managing two ToF sensors that have the same I2C address. To address this, I first connected each ToF sensor separately to the Artemis board and identified the I2C address of each device by running the I2C scanner example code. It was discovered that both sensors shared the same slave address. According to the datasheet, the slave address can be changed, and the installed library includes a function to modify the device address until it is reset or powered off. By connecting the shutdown pin on one of the ToF sensors to one of GPIO pin on the Artemis board and disabling it during startup by pulling the corresponding pin low, I was able to change the address of the other sensor to 0x30. 
                                After adjusting the address, I reactivated the ToF sensor with the original address of 0x29. The connetion schematic is shown below.    
                            </p>
                            <img src="Imgs_lab3/wiring.png" alt="Schematic for two ToF" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>Consequently, I successfully connected two ToF sensors to the Artemis board simultaneously, allowing both to function at the same time, as demonstrated in the video below.</p> 
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/kTmSqQkuPjw" title="two ToF are successfully connected" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">               
                            <h3 class="mb-0">ToF modes</h3>
                            <p>The library currently supports two distance measuring modes: setDistanceModeShort and setDistanceModeLong. I successfully configured each sensor with a different mode. By utilizing the getDistanceMode() function provided by the library, I confirmed the individual settings for each sensor, as demonstrated in the screenshot below.</p>                           
                            <img src="Imgs_lab3/two_modes.png" alt="two modes read data from two sensors" style="width: 40vw; height: 20vw;">
             
                            <br>
                            <h4 class="mb-0">Test with two modes</h4>
                            <p>I tested two sensors using two distinct modes: short mode and long mode, and generated graphs as illustrated in the screenshot below. The data collection occurred under normal lab ambient lighting conditions. Due to space limitations, I did not test distances beyond 1 meter, which falls within the valid range for both modes.it appears to be accurate enough. The teaching assistant instructed that there is no need to calculate the conversion factor.</p>
                            <img src="Imgs_lab3/floor_light.png" alt="two modes read data under ambient light" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>I also tested the two sensors in both short mode and long mode by covering the light, in contrast to the tests conducted under lab ambient lighting conditions (with all other conditions, such as distance measurement, being the same). I plotted the data as illustrated in the screenshot below.</p>
                            <img src="Imgs_lab3/floor_dark.png" alt="two modes read data by light being covered" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>
                                I also conducted tests on the two sensors using targets with different textures. The data previously collected were obtained using the lab floor as the target. I conducted additional tests using a cotton chair as the target; however, the data did not show any significant differences from the results illustrated in the screenshots above.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">How fast each sensor reads data</h3>
                            <p>I recorded the time stamp for each measurement taken by the sensor and calculated the average sampling rate to be approximately 0.143 seconds. This means the sensor records data at a frequency of about 6.98Hz, or every 0.143 seconds.
                            </p>
                            <br>
                            <p>I verified the readiness of the data from both sensors; if ready, the measurements were printed, otherwise, the time was printed by running the while loop in the main loop function. This process revealed that the main loop executes faster than the data collection by the sensors. Given that my current loop runs at approximately 7Hz, which is slower than expected, I reviewed my code in the Arduino IDE and consulted the Time-of-Flight (ToF) sensor's datasheet for insights. I discovered the slowdown was due to an excessive number of conditional checks in my loop, including checks on array length, data storage management, and executing 'start ranging and stop ranging' in every loop.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Bluetooth connection</h3>
                            <p>I carefully recorded time stamps of ToF data for 3 seconds and then sent the data over Bluetooth to my computer. The screenshot below shows the plot of the distance data over 3 seconds.
                            </p>
                            <img src="Imgs_lab3/3sdataToF.jpg" alt="3 seconds of ToF data sent over Bluetooth" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000-level student discussion: </h3>
                            <h4 class="mb-0">Pros/Cons of other distance sensors are based on infrared trasmission</h4>
                            <p>The Sharp GP2Y0A02YK0F infrared range sensor operates by emitting an infrared beam to measure distances between 20cm and 150cm. Its main advantages include ease of integration due to its analog output and its cost-effectiveness. However, its utility is limited by a shorter operational range and susceptibility to ambient light and reflectivity of the target. In contrast, the Ultrasonic Sensor HC-SR04, with a range of 2cm to 400cm, is not influenced by the target's color or material and remains affordable. Its accuracy, though, can be compromised by environmental factors like temperature and humidity, and its wider beam angle may reduce precision for specific targets. It also has a slower measurement speed due to the nature of sound wave propagation.
                                The VL53L1X Time-of-Flight (ToF) sensor, utilizing FlightSense technology, excels in delivering precise and quick distance measurements up to 4 meters, irrespective of target color and ambient light. This makes it ideal for real-time applications requiring reliable data. The primary drawback of the VL53L1X is its higher cost relative to the other sensors discussed.
                            </p>
                            <h4 class="mb-0">Sensitivity of ToF sensor VL53L1X to colors and textures</h4>
                            <p>
                                I evaluated the sensor's sensitivity to different textures by using the lab floor and a cotton chair as targets. The tests did not reveal any significant differences in the accuracy of the data collected. As mentioned in the datasheet for the VL53L1X sensor, the sensor employs FlightSense technology. This ensures that the sensor's performance is largely unaffected by ambient lighting conditions and target characteristics such as color, shape, texture, and reflectivity. This observation aligns with my discoveries from the tests mentioned above. According to the datasheet from Pololu, these external factors may only influence the maximum range of the sensor measurements. However, for the purposes of design and development in this lab, the impact of these external conditions is not deemed significant.
                            </p>
                        </div>
                    </div>
                    <br>
            </section>

            <hr class="m-0"/>

            <!-- Lab 4 -->
            <section class="resume-section" id="lab4">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB4: Motors and Open Loop Control</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>The objective of this laboratory session is to transition from manual control to automated open-loop control of the vehicle. The vehicle will be capable of performing a sequence of pre-defined maneuvers, utilizing the Artemis board in conjunction with two dual motor drivers.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">21th, Feb 2024 - 6th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Prelab on setting up</h3>
                            <p>The connections between the motor drivers, Artemis, and battery are shown as:</p>
                            <img src="Imgs_lab4/schematic.png" alt="schematic" style="width: 40vw; height: 20vw;">
                            <p>I selected pins 3, 5, A13, and A15 on the Artemis as the input for the motor drivers because these pins can generate Pulse-Width Modulation (PWM). This capability is indicated in the schematic by a "~" symbol preceding the pin numbers.</p>
                            <img src="Imgs_lab4/board_schematic.png" alt="board schematic" style="width: 30vw; height: 20vw;">
                            <p> As depicted in the schematic diagram above, I am using two separate batteries to power the Artemis and the motor drivers/motors. This approach is taken because motor drivers/motors typically consume a considerable amount of power. If the same battery were used to power both the Artemis board and the motor drivers/motors, it would likely result in an unstable power supply for the Artemis board, due to the high current draw from the motor drivers/motors.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Setup and Generating PWM signals</h3>                         
                            <h4 class="mb-0">DC Power Supply</h4>
                            <p>Initially, I powered the system using a power supply to perform a sanity check. I set the voltage to 3.7V, as the motor driver (DRV8833 by Pololu) operates within a range of 2.7V to 10.8V. Additionally, I capped the current at 2A, reflecting the peak output current the driver can handle. This measure serves as a precaution to protect the device in the event of a short circuit within the system.
                            </p>
                            
                            
                            <h4 class="mb-0">Oscilloscope</h4>
                            <p>Subsequently, I connected one of the motor driver inputs to Channel A of the oscilloscope to visualize the generated PWM signal and verify my approach.   
                            </p>

                            <h4 class="mb-0">Setup with power supply and oscilloscope</h4>
                            <p>The video below shows the whole connection with connecting the motors, the Artemis board, oscilloscope, and the power supply.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/R6V4tG-P7oI" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> The image below illustrates the PWM signal generated with approximately a 25% duty cycle, achieved by setting the PWM-related timer to run up to 63 out of a maximum value of 255. By analyzing the signal with an oscilloscope, I confirmed the accuracy of both my connections and my programming-level understanding of its operation. This successful verification has prepared me to advance further.</p>
                            <img src="Imgs_lab4/PWM.jpeg" alt="PWM signal" style="width: 40vw; height: 20vw;">
                            
                            <h4 class="mb-0">Wheels running</h4>
                            <p>The code snippet to operate one set of wheels is shown below.</p>
                            <img src="Imgs_lab4/Onesidewheelrunning.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                            <p>The video below showcases my ability to generate PWM signals and control the motor, which in turn drives the wheels. This system was powered by a DC power supply and was verified with an oscilloscope connected for monitoring.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/R6V4tG-P7oI" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>
                                The video below demonstrates that both sets of wheels can operate, with the system powered by two batteries: one 850mAh battery powers the Artemis board, and another 850mAh battery powers the motor drivers/motors.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/JyxlX80o42c" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Complete connections with all components on the car</h3>
                            <p>Following the schematic provided above for hardware connections, I connected the motor drivers as the image shows below. The figure below illustrates the connection of all components in the stunt car's system. Two time-of-flight sensors are installed at the front and rear edges of the car. The battery for the Artemis board, along with the board itself, is housed in a small basket. The IMU sensor is attached to a flat area of the axle on the car. Two motor drivers are positioned atop the battery case. The arrangement of the motor drivers and wires, secured with a zip tie, is also visible. Ultimately, the entire setup will be encased in tape to ensure its stability during operation. As depicted in the image, the battery laid out on the table will be inserted into the battery pack from the bottom and secured with tape to prevent it from dislodging during use.
                            </p>
                            <img src="Imgs_lab4/car_complet.jpg" alt="complet connections" style="width: 20vw; height: 30vw;">
                            <br>
                            <p>The figure below presents the final version of the stunt car, where tapes and zip ties were used to secure all mounted devices, ensuring they remain connected during high-speed tests, and the battery for the motors was inserted from the bottom and secured by being taped.</p> 
                            <img src="Imgs_lab4/finalcar.jpg" alt="final apperance of the car" style="width: 20vw; height: 30vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Lower limit in PWM</h3>
                            <p>As the video below demonstrates, this was just one of the tests I conducted to explore the value of duty cycle which could have the car start moving.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/RvDU2-VDVBk" title="pwm control wheels running against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> I began testing intuitively with a starting PWM signal of 25, but this was insufficient to rotate the wheels. After repeating the process, I eventually discovered that setting both motors to 35, which corresponds to approximately a 14% duty cycle, was enough to get the car start moving, as the video below shows.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Nw7JRzqgBPI" title="just against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Calibration of two motors</h3>
                            <p>Initially, when applying PWM signals with identical duty cycles to both motors, the car could not maintain a straight path, as shown in the video below.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/P6-0Su7MSRs" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>The code snippet below is used to test how applying the same duty cycle to two different motors affects their operation. This suggests the need for a calibration factor to ensure both motors operate at the same speed, allowing the car to move in a straight line.</p>
                            <img src="Imgs_lab4/beforecali.png" alt="code snippet for testing straight line" style="width: 40vw; height: 20vw;">
                            <p>Next, I adopted a trial-and-error method to reliably achieve straight-line movement of the car by adjusting the duty cycle of the PWM signal for the right-side motor, while keeping the duty cycle of the PWM signal for the left-side motor unchanged. I documented each pair of duty cycles that enabled the car to maintain a straight path as the picture below shows. 
                                The criteria for selecting the appropriate duty cycles, to ensure both motors operated at comparable speeds, were based on the car's ability to move in a straight line for a distance greater than 6 feet. Consequently, I collected and recorded the data, which detailed the relative duty cycles of the PWM signals supplied to both motors.</p>
                            <img src="Imgs_lab4/twodcdatapoints.png" alt="data points collected on Excel" style="width: 40vw; height: 20vw;">
                            <p>Next, I proceed to plot the relationship between the PWM signals sent to the left and right sets of wheels, as illustrated by the line graph analysis presented below.
                            </p>
                            <img src="Imgs_lab4/twomotorsrelationship.png" alt="data points relationship" style="width: 40vw; height: 20vw;">
                            <p>It is easy to deduce that the relationship is approximately linear based on the line graph analysis. Consequently, I generated a straight line to analyze the linear relationship between the PWM signals sent to the left and right motors. The mathematical function of this line is \(\boldsymbol{y = 0.87x + 15.54}\).</p>
                            <img src="Imgs_lab4/approximatelinearrelashionship.png" alt="data points linear relationship" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Open Loop Control</h3>
                            <p>I implemented code that initiates the car's movement in a straight line, followed immediately by a left turn. Next, it halts for a second before turning right. After another brief pause of a second, the car then proceeds to move backwards.
                            </p>
                            <img src="Imgs_lab4/openloop.png" alt="open loop control" style="width: 40vw; height: 20vw;">
                            <p>The detailed implementations of each function prototype are illustrated in the screenshots below.</p>
                            <img src="Imgs_lab4/turn:backcode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <img src="Imgs_lab4/straight-stopcode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <p>The video below demonstrates the successful operation of the implemented code, performing exactly as I anticipated.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/RvDU2-VDVBk" title="pwm control wheels running against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000-level student discussion: </h3>
                            <h4 class="mb-0">PWM frequency</h4>
                            <p>Based on the analysis from the oscilloscope image which is shown above, the PWM frequency was approximately 183 Hz. The function analogWrite() is generally running at 500Hz, but the datasheet of the Artemic board does not directly demonstrates the default PWM frequency. In this lab, we are only changing the duty cycle of the PWM signals, but not the frequency. The motor driver typically operates with an internal PWM frequency of around 50 kHz, as indicated in the image below. </p>
                            <img src="Imgs_lab4/PWMF.png" alt="motor driver pwm frequency" style="width: 40vw; height: 5vw;">
                            <p>Because we are utilizing a pre-set hardware PWM signal from a PWM pin on the Artemis board, it tends to be more reliable and accurate than a software PWM signal. Adjusting the PWM frequency through programming is possible, but it may cause less accurate behavior due to timing discrepancies. Furthermore, given the current speed and the RPM of the motors, there appears to be no advantage in altering the PWM frequency.</p>
                            <h4 class="mb-0">Lowest PWM value speed (Once in motion)</h4>
                            <p>
                                The video below demonstrates that a sufficient duty cycle allows the car to start moving, after which it shifts to a lower PWM duty cycle to maintain motion. The reduced duty cycle, at 33, results in the car moving at the lowest speed.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/MYVQKlaDHvc" title="pwm control wheels running at lowest duty cycle" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>The code to implement and test this functionality is displayed below. The car begins with a reasonable speed which overcomes the friction, and then the duty cycle is reduced to a level that allows the car to run as slowly as possible, as demonstrated in the video above.</p>
                            <img src="Imgs_lab4/lowestPWM.png" alt="lowest PWM code" style="width: 20vw; height: 30vw;">
                            <img src="Imgs_lab4/frictioncode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <p>I continued to conduct tests to determine the duration the car could maintain its lowest speed. Utilizing a duty cycle capable of overcoming friction, it was revealed that the car nearly comes to a halt after approximately 20 seconds. Ultimately, by setting a lower PWM duty cycle to 40—slightly above the threshold that enables the car to just barely move against friction—I was able to ensure the car maintained a reasonable low speed. This was achieved even though it was not the absolute lowest PWM duty cycle, as demonstrated below.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/kmjtuHRQrOE" title="now lowest PWM duty cycle" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <br>
            </section>

            <hr class="m-0"/>
            <!-- Lab 5 -->
            <section class="resume-section" id="lab5">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB5: Linear PID control and Linear interpolation</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>To initiate the PID controller lab, we set up a data acquisition system from the robot using Bluetooth, capturing operational data in a 2-D array of float values on the Arduino IDE. This PID-relevant data was then sent to a Jupyter Lab notebook on demand, facilitating subsequent analysis with Python.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">6th, Feb 2024 - 13th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Prelab on data acquisition</h3>
                            <p>
                            I started this lab with introducing two new command types in both Python and Arduino IDE to enable the communication via Bluetooth. The command Car_data triggers the car_starts flag, initiating data acquisition from the TOF (Time of Flight) sensor in the main loop. Concurrently, the recordError helper function, as illustrated in the screenshot below, captures the time elapsed between each TOF sensor measurement and calculates the error by comparing the current distance to the target distance. The second command, Send_data, activates the sending_data flag, enabling Python users to request data transmission from the Artemis board.
                            </p>
                            <img src="Imgs_lab5/start_record.png" alt="cmd type to get data" style="width: 35vw; height: 40vw;">
                            <img src="Imgs_lab5/send_data.png" alt="cmd type to send data" style="width: 20vw; height: 5vw;">
                            <p>The codes in Python execute the command in Arduino IDE are shown in the screenshot below.</p>
                            <img src="Imgs_lab5/python_screenshot.png" alt="code in Python" style="width: 40vw; height: 20vw;">
                            <p>Next, I began by establishing new data arrays to record the time taken for each data acquisition by the TOF sensor and the error, defined as the difference between the current and target distances, in this lab.</p>
                            <img src="Imgs_lab5/array_store_erro.png" alt="error stored in this array" style="width: 40vw; height: 10vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">P, I, D corresponding coefficients choice</h3>                         
                            <h4 class="mb-0">Propotional gain</h4>
                            <p>I began the lab by focusing on the Kp coefficient for proportional control, which uses the product of the error (the difference between the current and target distances) and Kp to estimate a pwm value, as per the equation: error * Kp. With the maximum pwm signal duty cycle set at 255 and the error at 3000 mm, I initially approximated Kp as 255/400 ≈ 0.6375, indicating that adjustments should be along with this scale of magnitude. After fine-tuning, Kp was finalized at 0.3, closely matching the anticipated range. The decrement in Kp value aimed to provide the car with a more gental thrust to move towards the target. With Kp alone integrated, the stunt car's motion, as depicted in the video, was observed.
                            </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/XpttTvVY76w" title="Kp = 0.3" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            
                            <h4 class="mb-0">Integral gain</h4>
                            <p>Following the adjustment of Kp, I incorporated the Ki parameter to address the steady-state error and mitigate the oscillation issue. The integral term consists of the sum of Ki times the product of the distance error and its sampling period, leading to an increasing integrated value over time. I initiated Ki at a significantly lower value than Kp, setting it at 0.02 to cautiously approach the integration effect.
                                However, through testing, it became apparent that Ki needed to be adjusted to a much higher value of 0.05 to effectively counteract the steady-state error. To prevent the integral term from becoming excessively large, I implemented a clamp on the error accumulator. Recognizing that the robot starts a considerable distance from the equilibrium point, I aimed to prevent excessive error accumulation. Therefore, I set the error accumulator clamp at approximately 1000mm, facilitating a smoother approach to equilibrium and easier correction of the car's trajectory.
                            </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/9khJhyMkpso" title="Ki = 0.05" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <h4 class="mb-0">Integrator wind-up</h4>
                            <p>When the car remains stationary and the error is non-zero, the integral term will persistently accumulate. This causes the integral term's contribution to the PWM signal to increase until the motor reaches saturation. Beyond this point, the integral term continues to grow, surpassing the saturation level of the motor. It will start to decrease only when the car moves past the set point or the target distance. </p>
                            <br>
                            <p>These are the conditions under which I prevent the integrator from accumulating further value:
                                First, I halt the increase of the integral term or stop its accumulation when the controller output is saturated, which I set max 40 duty cycles from itegral part, to prevent the integral term from increasing further.
                                Second, as observed from the graph "All data over time" above, the integral part (represented by the orange line), which is the product of the integral gain (Ki) and the accumulated distance error in this lab, continues to increase until the error becomes negative. Therefore, I prevent the integrator from accumulating when the controller output's sign matches the error's sign. In other words, as soon as the error changes sign, I release the clamp on the integrator term, allowing it to decrease immediately. This approach helps to limit overshoot.</p>
                            <h4 class="mb-0">Differential gain</h4>
                            <p>As demonstrated in the previous video, the stunt car exhibited slight overshooting, prompting the introduction of the Kd parameter. Kd, applied within the derivative term of the PID controller, anticipates future changes in error. When the error decreases rapidly, its derivative becomes significantly negative, leading the derivative term to counteract the proportional and integral terms by reducing motor speed. Kd's application involves it being multiplied by the change rate between consecutive distance measurements.
                                Initially, I set Kd to 10. However, subsequent observations indicated that this differential gain was insufficient to effectively counterbalance the contributions of the proportional and integral gains, as the car continued to overshoot its target. </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/Ol2U3PpHuqc" title="Kd = 10" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> To refine the controller's performance, I incrementally adjusted Kd by increments of 10, ultimately finding that a Kd value of 60 enabled the stunt car to move smoothly and stop in alignment with my expectations, effectively minimizing overshoot and enhancing control precision.</p>                   
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/rz3VzCsjSrs" title="Kd = 60" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>However, the car was slightly jittering while it was running and even after it stopped. The differential term is relatively challenging to handle, so I started to graphing the contributions from P, I, D terms to the PWM duty cycles control.  The entire differential term was calculated based on the error difference, which involves subtracting the previous error from the current distance error and then dividing by the elapsed time. The screenshot below illustrates how the PWM duty cycle changes as the PID controller contributes. The spike data results from the contribution of the D term. </p>
                            <img src="Imgs_lab5/nearby_two_erros.png" alt="two nearby errors monitored from D terms" style="width: 40vw; height: 20vw;">
                            <p>I suspected there could be a sudden change in the error, causing the D term to approach infinity due to division which is shown as spike. To address this, I began debugging by calculating the slope or the rate of error change. This was done by taking two sets of error data spaced at two different time points and dividing by the total amount of time elapsed.</p>
                            <img src="Imgs_lab5/data_furtheraway.png" alt="two errors further away monitored from D terms" style="width: 40vw; height: 20vw;">
                            <p>As shown in the screenshot, the spike problem has been mitigated, though it still exists. I adjusted the Kd parameter to 1 and conducted multiple tests, incrementally increasing Kd by 1 each time. When Kd reached 3, the resulting graph, as shown below, suggests that the issue I encountered earlier was due to an improper Kd parameter setting.</p>
                            <img src="Imgs_lab5/way_smaller_d.png" alt="with relatively nicer d" style="width: 40vw; height: 20vw;">
                            
                            <h4 class="mb-0">Sampling Time for PID control sending PWM signal</h4>
                            <p>The screenshot below displays the time difference measured at each iteration of the main loop. The average execution time of the main loop is 0.03 seconds.</p>
                            <img src="Imgs_lab5/PID_time.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                            
                            <p>The screenshot below shows the time period each time the TOF sensor measures a new distance. The average time it takes for the TOF sensor to collect data is 0.1 seconds.</p>
                            <img src="Imgs_lab5/TOF_time.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Extrapolation</h3>
                            <p>As illustrated by the error graph below, it is evident that the error updates slowly. This delay is primarily because the TOF sensor takes longer to collect a new data measurement. As discussed in the sampling time section above, the TOF sensor processing the measurement takes longer than the PID controller takes to update the PWM duty cycle. Consequently, given that a moving car might collide with an obstacle before receiving an updated error measurement from the TOF sensor, extrapolation could prove to be very beneficial.</p>
                            <img src="Imgs_lab5/error.png" alt="errors being stalled" style="width: 40vw; height: 20vw;">
                     
                            <p>Using the linear interpolation mathematical equation below, the data for a point on the graph can be obtained by calculating from two known data points.</p>
                            <img src="Imgs_lab5/interpolation_fomula.png" alt="linear intrapolation formula" style="width: 40vw; height: 20vw;">
                            <p>Therefore, I selected two data points obtained earlier and used them to calculate the subsequent distance error. This error is then used to adjust the Proportional, Integral, and Derivative (PID) terms, affecting the PWM duty cycle. Subsequently, this adjustment influences the car's speed and its distance to the target.</p>
                            <p>The code implemented for the logic is as the pseudocode described below: </p>
                  
                            <code>
                                <p> if (distanceSensor.checkForDataReady()) {</p>
                                <p style="margin-left: 2vw;">    intermediate_distance = distanceSensor.getDistance();</p>
                                <p style="margin-left: 2vw;">       data_obtained_time = millis();</p>
                                <p>}</p>
                                <p>else {</p>
                                <p style="margin-left: 2vw;">intermediate_distance = intermediate_distance + (current_time - data_obtained_time) * speed;</p>
                                <p>}</p>
                            </code>
                     
                            <p>As shown in the screenshot below, after extrapolation predicts the unknown data points while the TOF sensor's data is not ready, the distance error updates much more frequently, and the PWM signals used to control the car become more accurate.</p>
                            <img src="Imgs_lab5/extrapolation.png" alt="data points after extrapolation" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
            </section>

            <hr class="m-0"/>
            <!-- Lab 6 -->
            <section class="resume-section" id="lab6">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB6: Orientation PID control</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>This lab is designed to provide experience with orientation PID control using the IMU. Specifically, the objective of this lab is to control the yaw of a robotic car using the IMU by implementing PID controls on PWM signals sent to two motors. This will eventually enable the car to turn to a set angle by receiving commands via Bluetooth.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">13th, Feb 2024 - 20th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Prelab on data acquisition</h3>
                            <p>
                            I began this lab by creating a 2D array used to record the relevant data from the robot, as shown in the image below.
                            </p>
                            <img src="Imgs_lab6/array_declaratioon.png" alt="array declare" style="width: 40vw; height: 5vw;">
                            <p>To implement PID control for orientation, multiple types of data are required. Additionally, I included other values such as the value of the entire P term, which is the product of Kp and the angle error (the difference between the set angle and the current angle), as well as the values of the I and D terms, for further analysis, such as conducting graph analysis on the data sent from the robot to the Jupyter notebook.</p>
                            <img src="Imgs_lab6/data_recording.png" alt="cmd type to send data" style="width: 30vw; height: 10w;">
                            
                            <p>To capture data recorded during its rotation on the floor and transmitted from the robot to the Jupyter notebook, as well as to remotely control the car's orientation by sending commands from my laptop via bluetooth, three types of commands are implemented.</p>
                            <img src="Imgs_lab6/Start_case.png" alt="case of Start" style="width: 20vw; height: 40vw;">
                            <img src="Imgs_lab6/other_twocase.png" alt="case of Stop and Record data" style="width: 40vw; height: 20vw;">
                            <p>Command sending was implemented in the Jupyter Notebook, as illustrated below. Three specific cases—Start, Stop, and Send_data—were implemented for distinct purposes. The Start command allows the user to define three PID control parameters, offering a more convenient means to employ a trial-and-error strategy for identifying the optimal parameter pair for orientation control. It also facilitates setting different target angles to streamline subsequent testing. The Stop command sets the duty cycles of the PWM to zero for both motors, thereby stopping the car. The Send_data command prompts the robot to transmit all recorded data to Python, where a notification handler receives and stores the data in a list named 'data' for further analysis.</p>
                            <img src="Imgs_lab6/start_stop_py.png" alt="start stop py" style="width: 40vw; height: 10vw;">
                            <img src="Imgs_lab6/send_data.png" alt="send data cmd in py" style="width: 35vw; height: 40vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">PID Input Signal</h3>                         
                            <h4 class="mb-0">Propotional gain</h4>
                            <p>
                                I began the lab by focusing on the Kp coefficient for proportional control, which calculates a PWM value by multiplying the error (the difference between the current and target angles) with Kp, as shown by the equation: error_angle * Kp. Initially, I used the same Kp value of 0.3 that was used in a previous lab for distance PID control with TOF sensors. However, this value proved too small for orientation control, as the potential error, such as 90 degrees in this lab, is significantly less than the errors encountered in the previous lab, which could be as large as 4000mm. Consequently, I experimented with a Kp value of 3. As indicated by the graph below, the robot exhibited slight overshooting.
                            </p>
                            <img src="Imgs_lab6/OnlyKp=3.png" alt="only has Kp (3)" style="width: 40vw; height: 30vw;">
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/f9IDrcqePfA" title="Only Kp introduced, Kp = 0.3" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        
                            <p>
                                I also tested a Kp value of 5 to observe any changes. According to the screenshot and video, there were no significant differences. Therefore, to address the issue of overshooting, I introduced the derivative term. This term counteracts the rate of error change and is calculated by multiplying the change in error by the derivative coefficient, Kd.
                            </p>
                            <img src="Imgs_lab6/Kp=5.png" alt="only has Kp (5)" style="width: 40vw; height: 30vw;">
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/MYfkNFFGW4A" title="Only Kp introduced, Kp = 0.5" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            
                            <h4 class="mb-0">Differential gain</h4>
                            <p>As demonstrated in the previous video, the stunt car exhibited slight overshooting, prompting the introduction of the Kd parameter. Kd, applied within the derivative term of the PID controller, anticipates future changes in error. When the error decreases rapidly, its derivative becomes significantly negative, leading the derivative term to counteract the proportional and integral terms by reducing motor speed. Kd's application involves it being multiplied by the change rate between consecutive distance measurements.
                                Initially, I set Kd to 0.25. However, subsequent observations indicated that this differential gain was insufficient to effectively counterbalance the contributions of the proportional gains, as the car continued to overshoot its target. The graph analysis is shown below.</p>
                            <img src="Imgs_lab6/3|0|0.25.png" alt="Kp (3), Kd (0.25)" style="width: 40vw; height: 30vw;">
                            
                            <p> To refine the controller's performance, I incrementally adjusted Kd by doubling it to 0.5, but it made no significant difference and it shows that Kd = 0.25 was sufficient for the orientation control.</p>                   
                            <img src="Imgs_lab6/3|0|0.5.png" alt="Kp (3), Kd (0.5)" style="width: 40vw; height: 30vw;">

                            <p>As the screenshot above demonstrates, after introducing the Kd term, the overshooting issue was mitigated, and the error stabilized at a positive value. Interpreting the graph suggests that the overshooting was significantly reduced by the derivative gain's counteraction to the change in error. Consequently, the derivative gain had a more dominant effect than the contribution from the proportional term.</p>
                            <p>Moreover, to ensure that any future increases in derivative gain do not lead to sudden spikes in the derivative term—and consequently, spikes in the PWM duty cycle signal—I implemented FFT (Fast Fourier Transform) analysis on the derivative term, as illustrated by the screenshots below.</p>
                            <img src="Imgs_lab6/d_term_signal.png" alt="d term signal" style="width: 40vw; height: 30vw;">
                            <img src="Imgs_lab6/fft_d_term_signal.png" alt="d term signal after FFT" style="width: 40vw; height: 30vw;">
                            
                            <p>It appears that there is no significant high-frequency noise, so there is no need to worry about implementing a digital low-pass filter to address potential spikes caused by the derivative term. Currently, with Kp set to 3 and Kd set to 0.25, a steady error is observed as the screenshot above demonstrates, and the PD control is unable to self-correct. Therefore, the integral gain has been introduced.</p>
                            
                            <h4 class="mb-0">Integral gain</h4>
                            <p>Following the adjustment of Kp and Kd, I incorporated the Ki parameter to address the steady-state error. The integral term consists of the sum of Ki times the product of the error, which is the difference between the set angle and the current angle, and its sampling period, leading to an increasing integrated value over time. I initiated Ki at a significantly lower value than Kp, setting it at 0.1 to cautiously approach the integration effect.
                            </p>
                            <img src="Imgs_lab6/3|0.1|0.25.png" alt="kp = 3, ki = 0.1, kd = 0.25" style="width: 40vw; height: 30vw;">
                            <p>As illustrated in the screenshot above, the system performs well, and the error remains within an acceptable range. I implemented the PID control so that when the error angle falls within +/- 5 degrees of the set angle, the motors receive a 0 duty cycle. According to the graph analysis, the car behaved as expected.</p>
                            <p>For further testing, I experimented with another set of parameters: Kp set to 5, Ki set to 0.1, and Kd set to 0.25. The graph obtained during the test, while the car was rotating on the floor, indicates that the system still performed as expected.</p>
                            <img src="Imgs_lab6/5|0.1|0.25|90.0.png" alt="kp = 5, ki = 0.1, kd = 0.25" style="width: 40vw; height: 30vw;">
                            <p>Based on the graph, the increase in orientation change speed is evident. Consequently, I also increased Kd, which was set to 0.5. However, as Kd became more dominant, the steady error became more noticeable. Therefore, I eventually decided to stick with the set of parameters: Kp = 3, Ki = 0.1, and Kd = 0.25.</p>
                            <img src="Imgs_lab6/5|0.1|0.5|90.0.png" alt="kp = 3, ki = 0.1, kd = 0.5" style="width: 40vw; height: 30vw;">
        
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Discussion</h3>
                            <h4 class="mb-0">Are there any problems that digital integration might lead to over time? Are there ways to minimize these problems?</h4>
                            <p>
                                In digital integration, especially within the Integral component of a PID controller, there's a potential for what's called "integral windup." This occurs when the integral term accumulates a significant error over time, especially during periods when the actuator is saturated (cannot increase output further). This can lead to the system overshooting its target and exhibiting oscillatory behavior, which can be slow to correct.
                            </p>
                            <br> 
                            <h4 class="mb-0">Integrator wind-up</h4>
                            <p>When the car remains stationary and the error is non-zero, the integral term will persistently accumulate. This causes the integral term's contribution to the PWM signal to increase until the motor reaches saturation. Beyond this point, the integral term continues to grow, surpassing the saturation level of the motor. It will start to decrease only when the car moves past the set angle which when the error changes the sign, as how the orange line draws on the screenshot above. </p>
                            <br>
                            <p>These are the conditions under which I prevent the integrator from accumulating further value:
                                First, I halt the increase of the integral term or stop its accumulation when the controller output is saturated, which I set max 60 duty cycles from itegral part, to prevent the integral term from increasing further.
                                Second, as observed from the graph "All data over time" above, the integral part (represented by the orange line), which is the product of the integral gain (Ki) and the accumulated distance error in this lab, continues to increase until the error becomes negative. Therefore, I prevent the integrator from accumulating when the controller output's sign matches the error's sign. In other words, as soon as the error changes sign, I release the clamp on the integrator term, allowing it to decrease immediately. This approach helps to limit overshoot.</p>
                            <br>    
                            <h4 class="mb-0">Does your sensor have any bias, and are there ways to fix this?</h4>
                            <p>As is widely known, gyroscope sensors are prone to data drifting. I visualized this data drift by measuring the angle while keeping the car stationary.</p>
                            <img src="Imgs_lab6/data_drift.png" alt="data drifts on angel measurement" style="width: 40vw; height: 30vw;">
                            <p>There are several methods to mitigate data drifting. My approach involved accumulating 30 data points of the yaw value while the car was stationary, just before it began to move. I then calculated the average value of this noise. By subtracting this average noise value from subsequent yaw data measurements, I was able to significantly reduce the impact of data drift.</p>
                            <img src="Imgs_lab6/calculate_avg_noise.png" alt="calculate average data drifting noise" style="width: 40vw; height: 30vw;">
                            <br> 
                            <h4 class="mb-0">Are there limitations on the sensor itself to be aware of?</h4>
                            <p>As demonstrated in the screenshot below, by default, the gyroscope (referred to as myFSS.g) of this IMU is limited to sensing angle changes at a maximum rate of 250 degrees per second.</p>
                            <img src="Imgs_lab6/calculate_avg_noise.png" alt="calculate average data drifting noise" style="width: 40vw; height: 30vw;">
                            <p>I verified that my car reached this limitation by practically rotating the car on the floor, capturing the yaw data (myICM.gyrZ()), and graphing the results using Python, as displayed below.</p>
                            <img src="Imgs_lab6/250_limitation.png" alt="the car reached limimation" style="width: 40vw; height: 20vw;">  
                            <p>After increasing the speed limitation to 500 degrees per second, I repeated the graphing of the yaw data to ensure that the limitation was not exceeded.</p>
                            <img src="Imgs_lab6/500.png" alt="the car limimation changes to 500" style="width: 40vw; height: 20vw;">
                            <img src="Imgs_lab6/speed_500.png" alt="the car does not reach the limitation anymore" style="width: 40vw; height: 30vw;"> 
                            <p> The issue with the previous limitation was that the sensor's maximum sensing speed was reached, so ,for example, even though the car actually rotated 120 degrees, the sensor could only register a 90-degree rotation. This discrepancy was the cause of the observed overshooting.</p>
                            <br> 
                            <h4 class="mb-0">Does it make sense to take the derivative of a signal that is the integral of another signal?</h4>
                            <p>
                                In this orientation control lab, the angle signal is obtained from the integral of the yaw rotation velocity. The derivative term in a PID controller is utilized to compute the derivative of the error signal, which represents the discrepancy between the desired angle (setpoint) and the current angle. This term plays a crucial role in forecasting future errors and mitigating changes in the error. Given that the angle signal in this lab is derived by integrating rotational velocity, applying the derivative to the accumulated angle—which would yield the error's rate of change—might seem redundant. This is because the derivative term can be directly obtained from reading the gyro rotational velocity along with Z axis. Overall, the derivative term remains valuable for anticipating and correcting future errors, thereby reducing oscillations and improving the stability of the system.
                            </p>
                            <br> 
                            <h4 class="mb-0">Does changing your setpoint while the robot is running cause problems with your implementation of the PID controller?</h4>
                            <p>In this experiment, potential issues from sudden error changes are mitigated by two factors. First, the motor used responds too slowly to react immediately to abrupt changes in error. Second, there's a limitation on the maximum rotational velocity that further reduces the impact of any rapid error fluctuations.</p>
                            <br> 
                            <h4 class="mb-0">Is a lowpass filter needed before your derivative term?</h4>
                            <p>First, as demonstrated by all the screenshots above, the contribution of the derivative term to the PWM duty cycles does not result in significant spikes.</p>
                            <br>
                            <p>Also, after conducting FFT analysis on the derivative term multiple times, it appears that implementing a low-pass filter is not necessary.</p>
                            <img src="Imgs_lab6/noneedfor_lowpass.png" alt="no need for lpf" style="width: 40vw; height: 30vw;"> 
                            <br> 
                            <h4 class="mb-0">This is essential for being able to tune the PID gains/Set points quickly.</h4>
                            <h4 class="mb-0">Will you need to be able to update the setpoint in real time?</h4>
                            <p>In my setup, I've configured the case statement in the Arduino IDE to accept commands from the Jupyter Notebook. This setup enables the separate transmission of PID parameters and the setting of the target angle. As a result, my implementation allows for easy adjustments to the set angle by sending commands from the Jupyter Notebook to the robot via Bluetooth in real-time, as well as the modification of PID parameters on-the-fly.</p>
                            <br> 
                            <h4 class="mb-0">Can you control the orientation while the robot is driving forward or backward?</h4>
                            <p>I've realized that the stunt car can only rotate to a set angle and stops once the error—the difference between the set angle and the current angle—falls within an acceptable range of +/- 5 degrees, in this lab. To enhance this functionality, I could introduce a base duty cycle for the PWM signals sent to the motors. This would enable the car to continuously move forward or backward. At the same time, it could adjust the direction by controlling one specific motor. By adding extra duty cycle to the motor controlling one side of the wheels, for example, adding controls to the right side of wheels while the car is moving forward would allow the car to turn left.</p>
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Result</h3>
                            <p>
                                After fining a set of parameters for PID terms with Kp = 3, Ki = 0.1, Kd = 0.25, the car behaved as expected as shown in the video below. The screenshot shows the data about how the PID controls applies on controlling the car's orientation. 
                            </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/4wYemjrCr6w" title="oreintation control" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <img src="Imgs_lab6/perfect.png" alt="final analysis" style="width: 40vw; height: 30vw;">
                            
                        </div>
                    </div>

                

            </section>


            <hr class="m-0"/>
            <!-- Lab 7 -->
            <section class="resume-section" id="lab7">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB7: Kalman Filter</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>
                            The objective of this lab is to implement a Kalman Filter to predict the TOF (Time of Flight) values that are sampled at a slow rate. The aim is for the car to achieve the highest possible speed while maintaining the ability to halt 1ft from a wall or execute a turn within a 2ft range.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">20th, Feb 2024 - 27th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">ESTIMATE THE DRAG AND MOMENTUM OF THE ROBOT</h3>
                            <p>
                                Since the TOF sensor measures distance relatively slowly in comparison to its speed, a Kalman filter will be implemented in this lab to predict the robot's position using a state space model when the TOF sensor's data is unavailable.
                            </p>
                            <img src="Imgs_lab7/kalmanfilter.png" alt="kalman filter content" style="width: 40vw; height: 30vw;">
                            <p>
                                To determine the values of all coefficients required for the Kalman filter implementation, I began by calculating 'd' (drag) and 'm' (mass), which are utilized in the state prediction equation, as illustrated in the figure below.
                            </p>
                            <img src="Imgs_lab7/statespaceequa.png" alt="state space equation" style="width: 40vw; height: 30w;">
                           
                            <p> According to the lab handout, determining the value of 'd' (drag) requires finding the steady-state speed, and 'u' represents the input percentage, which is set to 1 (100% of input) during the implementation of the state space model.</p>
                            <img src="Imgs_lab7/findingd.png" alt="how to find d" style="width: 40vw; height: 20vw;">
                           
                            <p>To acquire the steady speed data for the robot in motion, I set the motor's duty cycle to 160 (out of 255) and directed the robot toward a wall. </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/hgDYtEtb5TU" title="running the car with 160" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>
                                The TOF sensor recorded the measurements, which were transmitted to the Jupyter notebook via Bluetooth. I then plotted both distance and velocity against time, as demonstrated in the following illustration.
                             </p>
                            <img src="Imgs_lab7/steadt_speed.png" alt="steady speed" style="width: 40vw; height: 30vw;">

                            <p>Based on the calculated steady speed of 3206.07 mm/s, I was able to calculate 'd' (drag coefficient) as 0.000311. Next, I needed to calculate 'm' (mass) using the value of 'd' (drag) and the time required for the robot to reach 90% of its steady speed. The equation used for calculating 'm' is presented below.</p>
                            <img src="Imgs_lab7/findingm.png" alt="finding m value" style="width: 40vw; height: 30vw;">
                            <p>
                                From the graph, I selected the point corresponding to approximately 90% of the steady speed, which is around 2600 mm/s. The time to reach 90% of the steady speed (t90%) is 1.16 seconds. Thus, after analyzing the data and applying the relevant equations, the mass 'm' is calculated to be 0.000157.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Initialize KF (Python)</h3>                         
                            <h4 class="mb-0">Compute the A, B, and C matrix</h4>
                            <p>
                                To implement the Kalman Filter effectively, it was necessary to discretize both the A and B matrices using the functions outlined below. This step ensures that the continuous-time model is accurately translated into a form suitable for digital computation.
                            </p>
                            <img src="Imgs_lab7/ABmatrix.png" alt="Discretize A B matrixes" style="width: 40vw; height: 30vw;">
                            
                            <p>
                                The function presented below utilizes Python to discretize the A and B matrices. This approach ensures the matrices are adapted for use in the discrete-time version of the Kalman Filter algorithm.
                            </p>
                            <img src="Imgs_lab7/discretizeAB.png" alt="discretize A B in python" style="width: 30vw; height: 10vw;">
                            
                            <p>The code snippet in the screenshot below demonstrates that I changed the TOF sensor's sampling rate from the default 100 ms to 20 ms. Consequently, the sampling rate used for calculating the A and B matrices was adjusted to 20 ms (0.02s).</p>
                            <img src="Imgs_lab7/changeSamplingrate.png" alt="change TOF sampling rate" style="width: 30vw; height: 10vw;">
                            
                            <p> The C matrix was given, highlighting that only the matrix entry corresponding to distance is needed for the calculations. Given that the car is moving towards the wall, this is represented with a negative sign in the matrix.
                            </p>
                            <img src="Imgs_lab7/ABC.png" alt="ABC matrix" style="width: 40vw; height: 30vw;">

                            <p>There are two matrices corresponding to noise that need to be accounted for in the implementation: 
                                sigma_z(\texttt{sig_z} in the screenshot below), which corresponds to measurement noise, and
                                sigma_u(\texttt{sig_u} in the screenshot below), which refers to process noise.
                            </p>
                            <img src="Imgs_lab7/sigmaz_sigmau.png" alt="sigma z and sigma u" style="width: 40vw; height: 8vw;">
                            
                            <p>Based on the provided standard deviations for position and speed, which are 20 mm and 20 mm/s respectively, these values were used in calculating the noise and uncertainty matrices.</p>
                            <img src="Imgs_lab7/matrixesinitialization.png" alt="sigma and sigma z and sigma u initialization" style="width: 40vw; height: 15vw;">

                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Implement and test your Kalman Filter in Jupyter (Python)</h3>
                            <h4 class="mb-0">Implementation of Kalman Filter</h4>
                            <p>
                                The implementation of the Kalman filter was given as depicted in the screenshot below.
                            </p>
                            <img src="Imgs_lab7/KFwasgiven.png" alt="given KF implementation" style="width: 40vw; height: 30vw;">

                            <p>Following the provided code snippet, I implemented the Kalman Filter using Python.</p>
                            <img src="Imgs_lab7/KFimplementation.png" alt="I implemented the KF using Python" style="width: 40vw; height: 30vw;">
                            
                            <p>To gain a deeper understanding of the Kalman Filter, I initially disabled its prediction functionality. I input only the actual TOF sensor measurements into the model and recorded the distances updated by the Kalman Filter, as implemented in the code snippet below.</p>
                            <img src="Imgs_lab7/noprediction.png" alt="only update distance" style="width: 40vw; height: 30vw;">

                            <p>Subsequently, I compared these real distance measurements with the data filtered by the Kalman Filter, as illustrated in the accompanying screenshot.</p>
                            <img src="Imgs_lab7/onlyupdatedataplot.png" alt="only update data no prediction" style="width: 40vw; height: 30vw;">
                            
                            <h4 class="mb-0">Parameters Discussion</h4>

                            <p>To visualize the impact of measurement and process noise on the Kalman filter model, I initially increased the measurement noise (sigma z) from 400 to 1000. The results, as shown below, are logical; a higher measurement noise suggests less confidence in the TOF sensor data, leading to readings that are far away from their actual values. Consequently, the Kalman Filter compensates by producing output values that are lower than the TOF data plot.</p>
                            <img src="Imgs_lab7/sigmaz100.png" alt="sigma z 1000" style="width: 40vw; height: 30vw;">  
                            
                            <p>Next, I increased the process noise (for both entries in sigma u ) from 400 to 1000. The results, as illustrated below, logically follow: a higher process noise implies greater trust in the model's ability to filter, resulting in readings that are very close to their actual values. Consequently, the Kalman Filter's output values almost overlap with the TOF data plot.</p>
                            <img src="Imgs_lab7/Sigmau100100.png" alt="trust the model more" style="width: 40vw; height: 30vw;">
                            
                            <h4 class="mb-0">Implemented Kalman Filter on linear PID control and interpolation (5000-level)</h4>
                            <p>
                                Initially, I operated the car towards the wall using PID control to halt at a predetermined point, without employing the Kalman Filter. I then collected the TOF measurement data, which was transmitted to the Jupyter notebook via Bluetooth.
                            </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/Xz6Jd519tXg" title="running the car towards the wall using PID control" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

                            <p>With a setpoint of 400mm from the wall, I collected data on the PWM duty cycle, which was implemented with integrator wind-up and derivative kick PID control, along with the distance measurements, as detailed below.</p>
                            <img src="Imgs_lab7/setpoint400.png" alt="set point 400" style="width: 40vw; height: 30vw;"> 

                            <p>Despite manually adjusting the TOF sensor's sampling rate from 100ms to 20ms, it remained insufficiently fast compared to the main loop, which controls the motor's PWM duty cycle. Therefore, I employed the Kalman filter to predict the car's position. The code snippet below illustrates how I manually inserted 5 data points, predicted by the Kalman Filter, recorded for later plotting.</p>
                            <img src="Imgs_lab7/updatepluspredi.png" alt="predict position when TOF data is not there" style="width: 40vw; height: 30vw;"> 
                            
                            <p>Plotting the KF estimated distance using Python is shown below. As can be seen, the red plot represents the KF estimate, which behaves as expected. Specifically, around the 20-second mark, the KF model predicts a lower distance, whereas the actual TOF sensor measurement increases. Consequently, the KF model quickly adjusts itself.</p>
                            <img src="Imgs_lab7/KFposPredict.png" alt="predict position when TOF data is not there" style="width: 40vw; height: 30vw;"> 
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Implement the Kalman Filter on the Robo</h3>
                            <p>
                                Now, since I have already understood and built the Kalman Filter model using Python, I've moved on to implementing the Kalman Filter on my robot. I started programming the matrices needed for the Kalman Filter in the Arduino IDE.    
                            </p>
                            <img src="Imgs_lab7/KFcoef.png" alt="matrixes and coefficients needed for KF" style="width: 35vw; height: 40vw;">
                            
                            <p>
                                Subsequently, I implemented the function 'KF' to update and predict a pair of data: the state (mu) and the uncertainty (sigma).
                            </p>
                            <img src="Imgs_lab7/KFfunc.png" alt="KF function in Arduino" style="width: 35vw; height: 40vw;">
                            <p>
                                Regarding the use of the Kalman Filter, the TOF sensor processes distance data relatively slowly. There are two scenarios: Firstly, when the TOF sensor data is available, we input the distance measurement into the Kalman Filter model to process the state (mu) and the uncertainty (sigma). The component of the state output corresponding to distance is then utilized to calculate the duty cycle via PID control, which drives the motor. Secondly, in the absence of TOF sensor data, we rely on the Kalman Filter for predictions. Subsequently, the PID control receives the distance error based on the predicted distance to calculate the PWM duty cycle, ensuring that the PID controller continues to control the vehicle even in the absence of actual TOF sensor data.
                            </p>
                            <img src="Imgs_lab7/useKF.png" alt="Use KF function in Arduino" style="width: 35vw; height: 40vw;">
                            <h4 class="mb-0">Result</h4>
                            <p>
                                Lastly, I operated the car towards the wall with the Kalman Filter applied, alongside the PID controller.
                            </p>
                            <iframe width="600vw" height="450vw" src="https://youtube.com/embed/SEVXws3wmDs" title="running the car with 160" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>
                                The data recorded and transmitted from the robot is plotted in the figure below. This plot confirms that the Kalman Filter is operational on the Artemis. It is observed that at approximately 23.7 seconds, the Kalman Filter predicts the position of the robot to be lower than its actual position, but it adjusts itself at a relatively fast pace.
                            </p>
                            <img src="Imgs_lab7/KFuse.png" alt="plot KF processed data" style="width: 40vw; height: 30vw;">
                        </div>
                    </div> 

            </section>



        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
