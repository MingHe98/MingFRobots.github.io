<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Resume - Start Bootstrap Theme</title>
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="#page-top">
                <span class="d-block d-lg-none">Ming He</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="assets/img/profile.jpg" alt="..." /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#about">Home</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab1">Lab 1: The Artemis board and Bluetooth</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab2">Lab 2: IMU</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab3">Lab 3: ToF</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab4">Lab 4: Motors and Open Loop Control</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#lab4">Lab 5: Linear PID control and Linear interpolation</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <!-- About-->
            <section class="resume-section" id="about">
                <div class="resume-section-content">
                    <h1 class="mb-0">
                        Ming He
                        <span class="text-primary"> ECE 5160 FAST ROBOTS</span>
                    </h1>
                    <div class="subheading mb-5">
                        LinkedIn: ww.linkedin.com/in/huaming-he
                        <br>
                        <a href="mailto:name@email.com">heyming98@gmail.com</a>
                    </div>
                    <p class="lead mb-5">Welcome to my Fast Robots website page.<br>I am an ECE student interested in robotics.</p>
                </div>
            </section>
            <hr class="m-0" />
            <!-- Lab 1-->
            <section class="resume-section" id="lab1">
                <div class="resume-section-content">
                    <h2 class="mb-5">LAB1: The Artemis board and Bluetooth</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Part1: Objective</h3>
                            <p>The goal of this part of the lab is to setup and become familiar with the Arduino IDE and the Artemis board. It covers skills in programming on Arduino IDE, testing board with LED blinks, communication over serial protocol, and the application of the onboard temperature sensor and Pulse Density Microphone.</p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">22nd, Jan 2024 - 7th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Blink it Up</h3>
                            <p>After successfully installing the SparkFun Apollo3 support software in the Arduino IDE and connecting the SparkFun RedBoard Artemis Nano to the laptop, I first tested programming the board by making an LED blink. In the example video below, the LED was on for 1 seconds, and then off for 1 second.</p>
                            <iframe width="auto" height="auto" src="https://www.youtube.com/embed/TP8BOoOqzuM" title="Blink LED up" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Serial Communication</h3>
                            <p>The screenshot below demonstrates how to test serial communication. In this example, the user types an input into the serial monitor, and the Artemis board reads this input and outputs it back to the serial monitor.</p>
                            <img src="Imgs_lab1/serial.jpg" alt="Serial Communication" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Analog Input Read</h3>
                            <p>The example video below demonstrates how to use the temperature sensor. The temperature recorded by the sensor on the Artemis board is sent to the serial monitor in Fahrenheit. To illustrate how the sensor responds, I covered the Artemis board with my hand, causing the temperature to increase to above 80°F.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/MeKUfqSYkI4" title="Temperature reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Microphone Usage</h3>
                            <p>The example video below demonstrates how to use the microphone on the Artemis board to detect the loudest frequency.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/gdvG9ffv2rc" title="Microphone reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) Example: Musical Tuner</h3>
                            <p>The example video below was used to identify the musical note "A". When the microphone detected an "A", corresponding to a sound frequency of approximately 526 Hz, the LED would turn on. For sounds of other frequencies, the LED remains off.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Ho1qV9jYgtg" title="Microphone reading" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <hr>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Part2: Objective</h3>
                            <p>The goal of part two is to establish Bluetooth communication between the computer and the Artemis board, utilizing Python in a Jupyter notebook and the Arduino programming language. This session aims to create a foundational framework for Bluetooth data transmission, setting the stage for its application in future lab exercises.</p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">22nd, Jan 2024 - 7th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Setup</h3>
                            <div class="subheading mb-3">Start Jupyter Server</div>
                            <p>After activating the virtual Python environment, I started the Jupyter server to use Jupyter notebooks for writing Python code.</p>
                            <img src="Imgs_lab1/Jupyter Lab.jpg" alt="Jupyter Lab Starts" style="width: 40vw; height: 20vw;">
                            <br>
                            <br>

                            <div class="subheading mb-3">Artemis Board Setup</div>
                            <p>After installing ArduinoBLE from the library manager in the Arduino IDE, I loaded and burned the sketch ble_arduino.ino onto the Artemis board from the ble_arduino directory in the codebase, following the instructions provided.</p>
                            <br>
                            <div class="subheading mb-3">Bluetooth Connection</div>
                            <p>After successfully setting up the Artemis board and starting the Jupyter server, the next step was to connect the Artemis board to the Python code. I first needed to read the MAC address of the Artemis board and replace the default MAC address in the Arduino code. After uploading the provided ble_arduino.ino code file to the Artemis board, the MAC address c0:89:f4:6b:86:4b was returned in the serial monitor, as shown in the figure below.</p>
                            <br>
                            <p>Since the BLEService is used in this lab, in addition to the MAC address, a UUID is also needed to identify the service. This is to differentiate the various types of data sent or received between the Artemis and the computer. Therefore, in the Jupyter Notebook, I ran the following code:
                               <br>
                               <i>from uuid import uuid4</i>
                               <br>
                               <i>uuid4()</i>
                               <br>
                               This generated a unique UUID, which I then assigned to the BLE service in both the Arduino IDE and the Jupyter notebooks.
                            </p>
                            <img src="Imgs_lab1/connection.jpg" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connection</h3>
                            <p>For the connection between the Artemis board and the computer, I first obtained the ArtemisBLEController object and connected to the Artemis Device before conducting any further tests.
                            </p>
                            <img src="Imgs_lab1/connected.png" alt="BLE connection" style="width: 40vw; height: 15w;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connection via commands</h3>
                            <p>For testing the connection between the Artemis board and the computer, some new commands were created and utilized for different tasks. When a new command type is introduced, it should be added to both the Arduino IDE and the Python code to ensure they can communicate correctly under a specific command.                                 
                            </p>

                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/cmdtypes_arduino.png" alt="command types in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/cmdtypes_python.png" alt="command types in Python" style="width: 30vw; height: 15vw;">
                            </div>
                        </div>
                    </div>    
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: ECHO Command</h3>  
                            <p>This ECHO command involved sending a string value to the Artemis board from the computer, which corresponds to the Python code. Then, the Artemis board sent back the augmented phrase, which had additional words added to the original phrase, as shown below in both the Jupyter notebooks and the Arduino IDE screenshot, to the computer.
                            </p>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/Echo_Arduino.png" alt="Echo command in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/Echo_python .png" alt="Echo command in Python" style="width: 30vw; height: 15vw;">
                            </div>

                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TIME_MILLIS Command</h3>
                            <p>The next command, GET_TIME_MILLIS, involved receiving the current time from the Artemis board by using the built-in millis() function in the Arduino IDE language. Following the instructions, I converted this value to an integer and sent it as a string to Python.
                            </p>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <img src="Imgs_lab1/millis_arduino.png" alt="Get millis in Arduino" style="width: 30vw; height: 15vw;">
                                <img src="Imgs_lab1/millis_python.png" alt="Get millis in Python" style="width: 30vw; height: 15vw;">
                            </div>
                        </div>
                    </div>              
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Notification Handler</h3>
                            <p>Instead of manually sending a command and then receiving the data, a notification handler could be used to monitor the data transfer. It is an asynchronous event handler, which means it would handle the case when the Artemis board is sending data and then receiving the data in Python.
                            <br><br>
                            The code below demonstrates how I used a notification handler to asynchronously receive the time data sent from the Artemis board.    
                            </p>
                            <img src="Imgs_lab1/event_handler.png" alt="Event handler" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TIME_MILLIS_3s Command</h3>
                            <p>The screenshot below demonstrates that I obtained the current time in milliseconds from the Artemis board and then sent it back to the laptop. After collecting these time values for 3 seconds, I was able to calculate an average speed of how fast messages can be sent. The effective data transfer rate of this method was 832 bytes/s.
                            </p>
                            <img src="Imgs_lab1/get_3s_time.png" alt="collect and send data for 3 secs" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: SEND_TIME_DATA</h3>
                            <p>Next, a new command, SEND_TIME_DATA, was introduced. In the Arduino IDE, I created a loop that, instead of sending each timestamp to the laptop, stored each timestamp in an integer array named time_stamps. By calling the command SEND_TIME_DATA, the Arduino code looped through the array and sent each data point as a string to the laptop for processing. Additionally, the data transfer rate was calculated, which was 411,000 bytes/s. This rate was in contrast to the previous method, which sent each timestamp immediately instead of storing them in an array.
                            </p>
                            <img src="Imgs_lab1/get_3s_time_inArray.png" alt="collect and send data stored in an array which collects 3 secs data" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: GET_TEMP_READINGS</h3>
                            <p>Next, as instructed, I added a second array of the same size as the time stamp array to store temperature readings. As shown in the screenshot below, each element in both arrays corresponded, meaning that the first timestamp was recorded at the same time as the first temperature reading. A command, GET_TEMP_READINGS, was introduced to loop through both arrays concurrently and send the data back to the laptop. I was able to configure the notification handler to manage the event and wrote code in Python to parse these strings, populating the data into two lists.
                            </p>
                            <img src="Imgs_lab1/get_timeTemp.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Example: Discussion about Two methods</h3>
                            <p>The first method involves the Artemis board sending data immediately as it becomes available, without any buffering. The second approach, on the other hand, has the Artemis board buffering data into a packet before sending it to the computer. This method is faster, as indicated by the results above. The Artemis board is equipped with 384 kB of RAM, and considering that one character (char) is equivalent to 1 byte, it has the capacity to store up to 384,000 characters in its memory for transmission without running out of space.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) : Effeefctive Data Rate And Overhead</h3>
                            <p>Next, I sent messages from the computer and received replies from the Artemis board. I calculated the data rate for 5-byte replies to be about 103 bytes/s and for 120-byte replies to be 1602 bytes/s. Additionally, to understand the relationship between the number of bytes and the data transfer rate, I tested multiple byte replies at intervals of 5. It was observed that the data rate increases with the amount of bytes sent, as depicted in the graph below. This trend indicates that larger replies reduce overhead. However, as shown on the graph, when the byte replies become too large—specifically, when they exceed 80 bytes—the trend might break, and the rate might drop to a lower rate than expected.      
                            </p>
                            <img src="Imgs_lab1/effective_rate.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                            <img src="Imgs_lab1/effective_rate_graph.png" alt="BLE connection" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">(5000-Level) : Reliability</h3>
                            <p>By modifying the code for the command SEND_TIME_DATA to send 10 unique data points at a high speed without any delay, the reliability of the Artemis was demonstrated. In the screenshot attached below, we can see that the data is reliable by comparing the data sent from the Artemis board and the data received on the laptop.
                            </p>
                            <img src="Imgs_lab1/reliability.png" alt="reliability" style="width: 50vw; height: 25vw;">
                        </div>
                    </div>

                </div>
            </section>
            <hr class="m-0"/>
            <!-- Lab 2 -->
            <section class="resume-section" id="lab2">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB2: IMU </h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Set Up the IMU</h3>
                            <p>The goal of this part of the lab is to set up and become familiar with the IMU. It covers skills in programming on the Arduino IDE, testing the IMU with collecting accelerometer and gyroscope data.
                            </p>
                            <br>
                            <p>Given that the IMU communicates with the Artemis board using the I2C protocol, knowing the slave address is crucial. The variable AD0_VAL signifies the last bit of the IMU's I2C address, which changes depending on the ADR jumper's connection. Initially, my IMU failed to provide any data, and the connection was unsuccessful because I had AD0_VAL set to 1, whereas it should have been 0 for my device.
                            </p>
                        
                            <img src="Imgs_lab2/IMU.jpg" alt="IMU connected" style="width: 40vw; height: 20vw;">
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">7th, Feb 2024 - 14th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Visualizing IMU Accelerometer and Gyroscope Data via Serial Plotter</h3>
                            <p>The IMU was first connected to the Artemis board via the QWIIC connectors. To set up the IMU in the software, the ICM_20948 library was installed in the Arduino IDE to enable communication between the Artemis board and the IMU, allowing for data collection. The accelerometer and gyroscope data were visualized using the serial plotter.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Arvwtrr1nNU" title="visualize data on better serial plotter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Visualizing the difference between accelerometer and gyroscope data via Serial Monitor</h3>
                            <p>Based on the data printed out on the serial monitor, the accelerometer data indicates the acceleration of motion around each coordinate axis. Thus, when moving the device along each axis, it is noticeable that the corresponding accelerometer data for that axis changes rapidly. The gyroscope measures the rate of angular rotation around the spatial coordinate axes. When the device is stationary, the data remains relatively small; however, it experiences a slight drift towards larger values.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/z9GX2oCY-sw" title="visualize data on better serial plotter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">               
                            <h3 class="mb-0">Accelerometer</h3>
                            <p>In order to use the accelerometer to determine tilt and roll, we can use the atan2 function, which returns a number in radians within the range [−π,π].
                                <br>The functions used here to calculate angles are:</p>
                                <p>\(\boldsymbol{\theta = \text{atan2}(a_x , a_z )}\)</p>
                                <p>\(\boldsymbol{\phi = \text{atan2}(a_y , a_z )}\)</p>
                            <p>The screenshot provided below demonstrates the implementation of the atan2 function to calculate the angles of pitch and roll in radians, which are then converted to degrees.</p>
                            <img src="Imgs_lab2/acc_data_degree.png" alt="acc_data in degree" style="width: 40vw; height: 20vw;">
                            <p>The video below illustrates the pitch and roll data being printed out. It clearly demonstrates that the system operates effectively within the range of -90 degrees to 90 degrees along both the x and y axes, showcasing the pitch and roll actions.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/ZZJBAAaZnvM" title="accelerometer data" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <br>
                            <h4 class="mb-0">Accelerometer Accuracy</h4>
                            <p>As I record the data for a few seconds at each angle (0, -90, 90) and review the recorded data, it appears to be accurate enough. The teaching assistant instructed that there is no need to calculate the conversion factor.</p>
                            <h4 class="mb-0">Accelerometer Noise</h4>
                            <p>As demonstrated in the video below, when the device is stationary, the signal in the time domain continues to fluctuate, indicating noise that may require attention.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/5N6rgU3tApM" title="accelerometer noise" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <br>
                            <p>
                            When inspecting the noise, a fast Fourier transform (FFT)—an algorithm that computes the discrete Fourier transform (DFT) of a sequence—plays a crucial role. It is instrumental in visualizing the data more effectively in the frequency domain
                            </p>
                            <br>
                            <p>
                            When the device is completely stationary, collecting the data and applying the Fast Fourier Transform (FFT) reveals the signal in the frequency domain, as shown below.
                            </p>
                            <img src="Imgs_lab2/stationary_fft.png" alt="stationary signal in frequency domain" style="width: 50vw; height: 25vw;">
                            <p>
                            However, when a vibration occurs during the collection of accelerometer data, the signal in the frequency domain appears as illustrated in the screenshot below.
                            </p>
                            <img src="Imgs_lab2/vibration_fft.png" alt="vibrated signal in frequency domain" style="width: 50vw; height: 25vw;">
                            <p>According to the datasheet, a hardware low pass filter is implemented, which explains the relatively clean signal in the FFT diagram when the device is stationary. New signals appearing up to about 30Hz were observed when vibration was introduced. Implementing a low pass filter via software might be beneficial. Based on the diagram, I selected a cut-off frequency of 10Hz.</p>
                            <br>
                            <p>The cut-off frequency was set at 10 Hz. Using the formula \(\boldsymbol{f = \frac{1}{2\pi RC}}\), where the f is the cut-off frequency, we can solve for the RC constant. Substituting \(\boldsymbol{f = 10}\)
                               into the equation yields an RC constant of approximately 0.0159155. Consequently, using the formula \(\boldsymbol{\alpha = \frac{T}{T + RC}}\), where T is the period corresponding to the sample rate (\(\boldsymbol{T = \frac{1}{\text{sample rate}}}\)), and the sample rate is determined by recording a certain number of data points over a specific period of time, which calculates to 294.76787030213706 Hz. This results in 
                               \(\boldsymbol{T = 0.00339\, \text{seconds}}\), and therefore, \(\boldsymbol{\alpha}\) is calculated to be approximately 0.1756.
                            </p>
                            <br>
                            <p>After introducing the low pass filter, which effectively reduces the noise to some extent, the data monitoring through the serial plotter is demonstrated in the video below. The video clearly distinguishes between the raw data, represented by the blue line, and the processed data, shown as the orange line, after implementing the low pass filter. It is evident that the low pass filter significantly reduces the noise.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/T6WbZIQKHvs" title="Low pass filter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>                          
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Gyroscope</h3>
                            <p>The gyroscope measures the rate of angular change in degrees per second. To calculate the angle, it adds the product of the angular rate and time to the current angle. A key advantage of the gyroscope is its lower noise levels compared to those of the accelerometer. However, a notable drawback is data drift over time. This means that even when the device is stationary on a table and the readings should ideally be zero, the data will gradually accumulate, leading to progressively larger values as time advances.</p>
                            <br>
                            <h4 class="mb-0">Data Drift</h4>
                            <p>The video below displays data measured from the gyroscope, clearly showing how the data drifts over time even when the device is stationary.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/XjH4_3PKiMI" title="data drifts" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>                                                     
                            <h4 class="mb-0">Comparison of data output: gyroscope data versus accelerometer data and accelerometer data processed with a Low Pass Filter (LPF)</h4>
                            <p>The video below demonstrates that the gyroscope data follows the same pattern as the accelerometer data, albeit with an increasing offset over time. This growing offset highlights the drift characteristic of gyroscope data.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/EG00ankJB1E" title="data comparison between gyro and accelerometer" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>Since calculating angles from gyroscope data is heavily dependent on the time difference between each data collection, the sample rate significantly impacts accuracy. After reducing the sample rate by introducing a delay, visualization of the gyro data through the serial plotter showed that updates to the new angles became slower and noticeably less accurate.</p>
                            <h4 class="mb-0">Complimentary Filter</h4>
                            <p>Despite the application recommended by the instructor, which is capable of auto-scaling the data, not functioning on my laptop, it is still evident that after implementing the complementary filter in my system, the vibrations caused no more than a 3-degree difference.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/T3YIsY8OFpc" title="Complimentary filter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>Additionally, the working range from -90 degrees to 90 degrees was verified.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Sample Data</h3>
                            <p>I increased the speed of IMU data collection by eliminating print statements and opting to store a time value at each iteration of the while loop, and store another time value when myICM.dataReady() returns true. This resulted in an average delay of approximately 0.0005 seconds between collections. However, this delay is expected to increase with the addition of more specific function calls and filter processing. Furthermore, by comparing two arrays that store time values for the main while loop and an inner loop—which merely checks for new IMU data readiness—the pacing between them appeared consistent.</p>
                            <br>
                            <h4 class="mb-0">Discussion</h4>
                            <h5>Consider if it makes sense to have one big array, or separate arrays for storing ToF, Accelerometer, and Gyroscope data</h5>
                            <p>Storing data in separate arrays is more logical because each sensor—Time-of-Flight (ToF), Accelerometer, and Gyroscope—generates data with distinct meanings and units. Separate arrays ensure clearer organization, simplifying data processing and analysis. This is particularly important for cases like the Accelerometer, which requires the implementation of a Low Pass Filter, whereas Gyroscope data does not. Thus, processing data from different sensors may necessitate different filters or logic, indicating that using separate arrays can streamline implementation.</p>
                            <h5>Consider the best data type to store your data. Should you use string, floats, double, integers?</h5>
                            <p>For the Time-of-Flight (ToF) sensor, integers should be sufficient since distances are typically measured in whole numbers of millimeters or centimeters. However, floats are necessary if the application requires more precise distance measurements. For both the gyroscope and accelerometer, which measure different parameters, floats are adequate because they offer a good balance between precision and memory usage.</p>
                            <h5>Consider the memory of the Artemis; how much memory can you allocate to your arrays? What does that correspond to in seconds?</h5>
                            <p>Assuming I have three separate arrays for the three sensors—ToF, Gyroscope, and Accelerometer—with each sensor's reading represented as a single float, I would need 12 bytes per set of sensor readings (4 bytes × 3). Assuming the entire 384 KB of RAM is available for data storage and with a sampling rate of 100 readings per second, I can store approximately 32,000 sets of data points. This corresponds to about 320 seconds, which is equivalent to approximately 5 minutes and 20 seconds of data at a sampling rate of 100 Hz.</p>
                            <h4 class="mb-0">Demonstration of data collection for over 5 seconds</h4>
                            <p>The image below demonstrates that the board is capable of capturing data for more than 5 seconds and then transmitting it to the computer via Bluetooth.</p>
                            <img src="Imgs_lab2/5seconds data.png" alt="5s data collection" style="width: 35vw; height: 10vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Stunt Car Record</h3>
                            <p>The video below showcases the stunt car in action. I've tested its movements forward, backward, turning around, and even flipping. The car is highly sensitive and fast, making it challenging to prevent collisions with walls or to avoid flipping due to its speed.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/7lDsMkM2NdQ" title="Stunt Car" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>As the instructor clarified, there is currently no need to mount the IMU on the car for testing.</p>
                        </div>
                    </div>
            </section>

            <hr class="m-0"/>
            <!-- Lab 3 -->
            <section class="resume-section" id="lab3">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB3: Time of Flight Sensors </h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Power up your Artemis with a battery</h3>
                            <p>In constructing the project, it is essential to acquire a JST connector and a battery as primary components. The process involves carefully cutting the battery wires individually to avoid simultaneously shorting the terminals, which could result in battery damage. Subsequent steps include soldering the battery wires to the JST jumper wires, and to ensure long-term durability and safety, insulating the exposed wire sections with heat shrink over electrical tape. Additionally, verifying the wire polarity is crucial, with the positive terminal of the battery connecting to the positive terminal on the Artemis device. The final stage involves powering the Artemis without the use of the USB C port, facilitating the testing of Bluetooth Low Energy (BLE) communications between the laptop and the Artemis, thereby confirming the device's proper operational status and its ability to transmit messages wirelessly. The system powered by the battery functions as expected, which is illustrated in the picture below.
                            </p>
                            <img src="Imgs_lab3/BatPower.png" alt="the Artemis board is powered by battery" style="width: 35vw; height: 15vw;">
                            
                            <p>The video below demonstrates the successful powering of the Artemis board and the use of the 'ECHO' command to send a message to the Artemis board. I received a response from the Artemis board, confirming its operational status without the need for power from a USB C port. This indicates that I successfully got the Artemis board to work wirelessly.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/dkHCcvXffO0" title="power the artmis board by battery" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">14th, Feb 2024 - 21th Feb 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Set up the ToF sensor</h3>
                            <p>Starting by cutting one end of a QWIIC cable and removing the protective film, I then soldered the other end to the ToF sensor. After successfully installing the SparkFun VL53L1X 4m laser distance sensor library, I tested the ToF sensor by connecting it to the Artemis Board to read data from it. One challenge I encountered during this process was that it was my first time using a QWIIC connection. I needed to identify that the blue cord connected to SDA and the yellow cord connected to SCL before I started soldering the wires.</p>
                        </div>

                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">I2C Address Scanning</h3>
                            <p>There is an example sketch within the installed library that I used to scan for the I2C address of the device. The device was successfully identified, and its slave address is 0x29, as illustrated in the screenshot below.</p>
                            <img src="Imgs_lab3/I2C_address.png" alt="I2C address for ToF" style="width: 40vw; height: 20vw;">
                            <p>The I2C address matched my expectations. According to the datasheet, "The sensor's 7-bit slave address defaults to 0101001b on power-up." The I2C scanner code returned 0x29, which is accurate because 0101001b is equal to 0x29 in hexadecimal.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Connect two ToF</h3>
                            <p>In this lab, two ToF sensors are used, which presents the challenge of managing two ToF sensors that have the same I2C address. To address this, I first connected each ToF sensor separately to the Artemis board and identified the I2C address of each device by running the I2C scanner example code. It was discovered that both sensors shared the same slave address. According to the datasheet, the slave address can be changed, and the installed library includes a function to modify the device address until it is reset or powered off. By connecting the shutdown pin on one of the ToF sensors to one of GPIO pin on the Artemis board and disabling it during startup by pulling the corresponding pin low, I was able to change the address of the other sensor to 0x30. 
                                After adjusting the address, I reactivated the ToF sensor with the original address of 0x29. The connetion schematic is shown below.    
                            </p>
                            <img src="Imgs_lab3/wiring.png" alt="Schematic for two ToF" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>Consequently, I successfully connected two ToF sensors to the Artemis board simultaneously, allowing both to function at the same time, as demonstrated in the video below.</p> 
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/kTmSqQkuPjw" title="two ToF are successfully connected" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">               
                            <h3 class="mb-0">ToF modes</h3>
                            <p>The library currently supports two distance measuring modes: setDistanceModeShort and setDistanceModeLong. I successfully configured each sensor with a different mode. By utilizing the getDistanceMode() function provided by the library, I confirmed the individual settings for each sensor, as demonstrated in the screenshot below.</p>                           
                            <img src="Imgs_lab3/two_modes.png" alt="two modes read data from two sensors" style="width: 40vw; height: 20vw;">
             
                            <br>
                            <h4 class="mb-0">Test with two modes</h4>
                            <p>I tested two sensors using two distinct modes: short mode and long mode, and generated graphs as illustrated in the screenshot below. The data collection occurred under normal lab ambient lighting conditions. Due to space limitations, I did not test distances beyond 1 meter, which falls within the valid range for both modes.it appears to be accurate enough. The teaching assistant instructed that there is no need to calculate the conversion factor.</p>
                            <img src="Imgs_lab3/floor_light.png" alt="two modes read data under ambient light" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>I also tested the two sensors in both short mode and long mode by covering the light, in contrast to the tests conducted under lab ambient lighting conditions (with all other conditions, such as distance measurement, being the same). I plotted the data as illustrated in the screenshot below.</p>
                            <img src="Imgs_lab3/floor_dark.png" alt="two modes read data by light being covered" style="width: 40vw; height: 20vw;">
                            <br>
                            <p>
                                I also conducted tests on the two sensors using targets with different textures. The data previously collected were obtained using the lab floor as the target. I conducted additional tests using a cotton chair as the target; however, the data did not show any significant differences from the results illustrated in the screenshots above.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">How fast each sensor reads data</h3>
                            <p>I recorded the time stamp for each measurement taken by the sensor and calculated the average sampling rate to be approximately 0.143 seconds. This means the sensor records data at a frequency of about 6.98Hz, or every 0.143 seconds.
                            </p>
                            <br>
                            <p>I verified the readiness of the data from both sensors; if ready, the measurements were printed, otherwise, the time was printed by running the while loop in the main loop function. This process revealed that the main loop executes faster than the data collection by the sensors. Given that my current loop runs at approximately 7Hz, which is slower than expected, I reviewed my code in the Arduino IDE and consulted the Time-of-Flight (ToF) sensor's datasheet for insights. I discovered the slowdown was due to an excessive number of conditional checks in my loop, including checks on array length, data storage management, and executing 'start ranging and stop ranging' in every loop.
                            </p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Bluetooth connection</h3>
                            <p>I carefully recorded time stamps of ToF data for 3 seconds and then sent the data over Bluetooth to my computer. The screenshot below shows the plot of the distance data over 3 seconds.
                            </p>
                            <img src="Imgs_lab3/3sdataToF.jpg" alt="3 seconds of ToF data sent over Bluetooth" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000-level student discussion: </h3>
                            <h4 class="mb-0">Pros/Cons of other distance sensors are based on infrared trasmission</h4>
                            <p>The Sharp GP2Y0A02YK0F infrared range sensor operates by emitting an infrared beam to measure distances between 20cm and 150cm. Its main advantages include ease of integration due to its analog output and its cost-effectiveness. However, its utility is limited by a shorter operational range and susceptibility to ambient light and reflectivity of the target. In contrast, the Ultrasonic Sensor HC-SR04, with a range of 2cm to 400cm, is not influenced by the target's color or material and remains affordable. Its accuracy, though, can be compromised by environmental factors like temperature and humidity, and its wider beam angle may reduce precision for specific targets. It also has a slower measurement speed due to the nature of sound wave propagation.
                                The VL53L1X Time-of-Flight (ToF) sensor, utilizing FlightSense technology, excels in delivering precise and quick distance measurements up to 4 meters, irrespective of target color and ambient light. This makes it ideal for real-time applications requiring reliable data. The primary drawback of the VL53L1X is its higher cost relative to the other sensors discussed.
                            </p>
                            <h4 class="mb-0">Sensitivity of ToF sensor VL53L1X to colors and textures</h4>
                            <p>
                                I evaluated the sensor's sensitivity to different textures by using the lab floor and a cotton chair as targets. The tests did not reveal any significant differences in the accuracy of the data collected. As mentioned in the datasheet for the VL53L1X sensor, the sensor employs FlightSense technology. This ensures that the sensor's performance is largely unaffected by ambient lighting conditions and target characteristics such as color, shape, texture, and reflectivity. This observation aligns with my discoveries from the tests mentioned above. According to the datasheet from Pololu, these external factors may only influence the maximum range of the sensor measurements. However, for the purposes of design and development in this lab, the impact of these external conditions is not deemed significant.
                            </p>
                        </div>
                    </div>
                    <br>
            </section>

            <hr class="m-0"/>

            <!-- Lab 4 -->
            <section class="resume-section" id="lab4">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB4: Motors and Open Loop Control</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>The objective of this laboratory session is to transition from manual control to automated open-loop control of the vehicle. The vehicle will be capable of performing a sequence of pre-defined maneuvers, utilizing the Artemis board in conjunction with two dual motor drivers.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">21th, Feb 2024 - 6th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Prelab on setting up</h3>
                            <p>The connections between the motor drivers, Artemis, and battery are shown as:</p>
                            <img src="Imgs_lab4/schematic.png" alt="schematic" style="width: 40vw; height: 20vw;">
                            <p>I selected pins 3, 5, A13, and A15 on the Artemis as the input for the motor drivers because these pins can generate Pulse-Width Modulation (PWM). This capability is indicated in the schematic by a "~" symbol preceding the pin numbers.</p>
                            <img src="Imgs_lab4/board_schematic.png" alt="board schematic" style="width: 30vw; height: 20vw;">
                            <p> As depicted in the schematic diagram above, I am using two separate batteries to power the Artemis and the motor drivers/motors. This approach is taken because motor drivers/motors typically consume a considerable amount of power. If the same battery were used to power both the Artemis board and the motor drivers/motors, it would likely result in an unstable power supply for the Artemis board, due to the high current draw from the motor drivers/motors.</p>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Setup and Generating PWM signals</h3>                         
                            <h4 class="mb-0">DC Power Supply</h4>
                            <p>Initially, I powered the system using a power supply to perform a sanity check. I set the voltage to 3.7V, as the motor driver (DRV8833 by Pololu) operates within a range of 2.7V to 10.8V. Additionally, I capped the current at 2A, reflecting the peak output current the driver can handle. This measure serves as a precaution to protect the device in the event of a short circuit within the system.
                            </p>
                            
                            
                            <h4 class="mb-0">Oscilloscope</h4>
                            <p>Subsequently, I connected one of the motor driver inputs to Channel A of the oscilloscope to visualize the generated PWM signal and verify my approach.   
                            </p>

                            <h4 class="mb-0">Setup with power supply and oscilloscope</h4>
                            <p>The video below shows the whole connection with connecting the motors, the Artemis board, oscilloscope, and the power supply.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/R6V4tG-P7oI" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> The image below illustrates the PWM signal generated with approximately a 25% duty cycle, achieved by setting the PWM-related timer to run up to 63 out of a maximum value of 255. By analyzing the signal with an oscilloscope, I confirmed the accuracy of both my connections and my programming-level understanding of its operation. This successful verification has prepared me to advance further.</p>
                            <img src="Imgs_lab4/PWM.jpeg" alt="PWM signal" style="width: 40vw; height: 20vw;">
                            
                            <h4 class="mb-0">Wheels running</h4>
                            <p>The code snippet to operate one set of wheels is shown below.</p>
                            <img src="Imgs_lab4/Onesidewheelrunning.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                            <p>The video below showcases my ability to generate PWM signals and control the motor, which in turn drives the wheels. This system was powered by a DC power supply and was verified with an oscilloscope connected for monitoring.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/R6V4tG-P7oI" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>
                                The video below demonstrates that both sets of wheels can operate, with the system powered by two batteries: one 850mAh battery powers the Artemis board, and another 850mAh battery powers the motor drivers/motors.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/JyxlX80o42c" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Complete connections with all components on the car</h3>
                            <p>Following the schematic provided above for hardware connections, I connected the motor drivers as the image shows below. The figure below illustrates the connection of all components in the stunt car's system. Two time-of-flight sensors are installed at the front and rear edges of the car. The battery for the Artemis board, along with the board itself, is housed in a small basket. The IMU sensor is attached to a flat area of the axle on the car. Two motor drivers are positioned atop the battery case. The arrangement of the motor drivers and wires, secured with a zip tie, is also visible. Ultimately, the entire setup will be encased in tape to ensure its stability during operation. As depicted in the image, the battery laid out on the table will be inserted into the battery pack from the bottom and secured with tape to prevent it from dislodging during use.
                            </p>
                            <img src="Imgs_lab4/car_complet.jpg" alt="complet connections" style="width: 20vw; height: 30vw;">
                            <br>
                            <p>The figure below presents the final version of the stunt car, where tapes and zip ties were used to secure all mounted devices, ensuring they remain connected during high-speed tests, and the battery for the motors was inserted from the bottom and secured by being taped.</p> 
                            <img src="Imgs_lab4/finalcar.jpg" alt="final apperance of the car" style="width: 20vw; height: 30vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Lower limit in PWM</h3>
                            <p>As the video below demonstrates, this was just one of the tests I conducted to explore the value of duty cycle which could have the car start moving.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/RvDU2-VDVBk" title="pwm control wheels running against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> I began testing intuitively with a starting PWM signal of 25, but this was insufficient to rotate the wheels. After repeating the process, I eventually discovered that setting both motors to 35, which corresponds to approximately a 14% duty cycle, was enough to get the car start moving, as the video below shows.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Nw7JRzqgBPI" title="just against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Calibration of two motors</h3>
                            <p>Initially, when applying PWM signals with identical duty cycles to both motors, the car could not maintain a straight path, as shown in the video below.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/P6-0Su7MSRs" title="pwm control wheels running and powered by DC power supply" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>The code snippet below is used to test how applying the same duty cycle to two different motors affects their operation. This suggests the need for a calibration factor to ensure both motors operate at the same speed, allowing the car to move in a straight line.</p>
                            <img src="Imgs_lab4/beforecali.png" alt="code snippet for testing straight line" style="width: 40vw; height: 20vw;">
                            <p>Next, I adopted a trial-and-error method to reliably achieve straight-line movement of the car by adjusting the duty cycle of the PWM signal for the right-side motor, while keeping the duty cycle of the PWM signal for the left-side motor unchanged. I documented each pair of duty cycles that enabled the car to maintain a straight path as the picture below shows. 
                                The criteria for selecting the appropriate duty cycles, to ensure both motors operated at comparable speeds, were based on the car's ability to move in a straight line for a distance greater than 6 feet. Consequently, I collected and recorded the data, which detailed the relative duty cycles of the PWM signals supplied to both motors.</p>
                            <img src="Imgs_lab4/twodcdatapoints.png" alt="data points collected on Excel" style="width: 40vw; height: 20vw;">
                            <p>Next, I proceed to plot the relationship between the PWM signals sent to the left and right sets of wheels, as illustrated by the line graph analysis presented below.
                            </p>
                            <img src="Imgs_lab4/twomotorsrelationship.png" alt="data points relationship" style="width: 40vw; height: 20vw;">
                            <p>It is easy to deduce that the relationship is approximately linear based on the line graph analysis. Consequently, I generated a straight line to analyze the linear relationship between the PWM signals sent to the left and right motors. The mathematical function of this line is \(\boldsymbol{y = 0.87x + 15.54}\).</p>
                            <img src="Imgs_lab4/approximatelinearrelashionship.png" alt="data points linear relationship" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Open Loop Control</h3>
                            <p>I implemented code that initiates the car's movement in a straight line, followed immediately by a left turn. Next, it halts for a second before turning right. After another brief pause of a second, the car then proceeds to move backwards.
                            </p>
                            <img src="Imgs_lab4/openloop.png" alt="open loop control" style="width: 40vw; height: 20vw;">
                            <p>The detailed implementations of each function prototype are illustrated in the screenshots below.</p>
                            <img src="Imgs_lab4/turn:backcode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <img src="Imgs_lab4/straight-stopcode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <p>The video below demonstrates the successful operation of the implemented code, performing exactly as I anticipated.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/RvDU2-VDVBk" title="pwm control wheels running against friction" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>

                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">5000-level student discussion: </h3>
                            <h4 class="mb-0">PWM frequency</h4>
                            <p>Based on the analysis from the oscilloscope image which is shown above, the PWM frequency was approximately 183 Hz. The function analogWrite() is generally running at 500Hz, but the datasheet of the Artemic board does not directly demonstrates the default PWM frequency. In this lab, we are only changing the duty cycle of the PWM signals, but not the frequency. The motor driver typically operates with an internal PWM frequency of around 50 kHz, as indicated in the image below. </p>
                            <img src="Imgs_lab4/PWMF.png" alt="motor driver pwm frequency" style="width: 40vw; height: 5vw;">
                            <p>Because we are utilizing a pre-set hardware PWM signal from a PWM pin on the Artemis board, it tends to be more reliable and accurate than a software PWM signal. Adjusting the PWM frequency through programming is possible, but it may cause less accurate behavior due to timing discrepancies. Furthermore, given the current speed and the RPM of the motors, there appears to be no advantage in altering the PWM frequency.</p>
                            <h4 class="mb-0">Lowest PWM value speed (Once in motion)</h4>
                            <p>
                                The video below demonstrates that a sufficient duty cycle allows the car to start moving, after which it shifts to a lower PWM duty cycle to maintain motion. The reduced duty cycle, at 33, results in the car moving at the lowest speed.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/MYVQKlaDHvc" title="pwm control wheels running at lowest duty cycle" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>The code to implement and test this functionality is displayed below. The car begins with a reasonable speed which overcomes the friction, and then the duty cycle is reduced to a level that allows the car to run as slowly as possible, as demonstrated in the video above.</p>
                            <img src="Imgs_lab4/lowestPWM.png" alt="lowest PWM code" style="width: 20vw; height: 30vw;">
                            <img src="Imgs_lab4/frictioncode.png" alt="code implementation" style="width: 20vw; height: 40vw;">
                            <p>I continued to conduct tests to determine the duration the car could maintain its lowest speed. Utilizing a duty cycle capable of overcoming friction, it was revealed that the car nearly comes to a halt after approximately 20 seconds. Ultimately, by setting a lower PWM duty cycle to 40—slightly above the threshold that enables the car to just barely move against friction—I was able to ensure the car maintained a reasonable low speed. This was achieved even though it was not the absolute lowest PWM duty cycle, as demonstrated below.</p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/kmjtuHRQrOE" title="now lowest PWM duty cycle" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    </div>
                    <br>
            </section>

            <hr class="m-0"/>
            <!-- Lab 5 -->
            <section class="resume-section" id="lab4">
                <div class="resume-section-content">
                    <h2 class="mb-5"> LAB5: Linear PID control and Linear interpolation</h2>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Introduction</h3>
                            <p>To initiate the PID controller lab, we set up a data acquisition system from the robot using Bluetooth, capturing operational data in a 2-D array of float values on the Arduino IDE. This PID-relevant data was then sent to a Jupyter Lab notebook on demand, facilitating subsequent analysis with Python.
                            </p>
                        </div>
                        <div class="flex-shrink-0"><span class="text-primary">6th, Feb 2024 - 13th Mar 2024</span></div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Prelab on data acquisition</h3>
                            <p>
                            I started this lab with introducing two new command types in both Python and Arduino IDE to enable the communication via Bluetooth. The command Car_data triggers the car_starts flag, initiating data acquisition from the TOF (Time of Flight) sensor in the main loop. Concurrently, the recordError helper function, as illustrated in the screenshot below, captures the time elapsed between each TOF sensor measurement and calculates the error by comparing the current distance to the target distance. The second command, Send_data, activates the sending_data flag, enabling Python users to request data transmission from the Artemis board.
                            </p>
                            <img src="Imgs_lab5/start_record.png" alt="cmd type to get data" style="width: 35vw; height: 40vw;">
                            <img src="Imgs_lab5/send_data.png" alt="cmd type to send data" style="width: 20vw; height: 5vw;">
                            <p>The codes in Python execute the command in Arduino IDE are shown in the screenshot below.</p>
                            <img src="Imgs_lab5/python_screenshot.png" alt="code in Python" style="width: 40vw; height: 20vw;">
                            <p>Next, I began by establishing new data arrays to record the time taken for each data acquisition by the TOF sensor and the error, defined as the difference between the current and target distances, in this lab.</p>
                            <img src="Imgs_lab5/array_store_erro.png" alt="error stored in this array" style="width: 40vw; height: 10vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">P, I, D corresponding coefficients choice</h3>                         
                            <h4 class="mb-0">Propotional gain</h4>
                            <p>I began the lab by focusing on the Kp coefficient for proportional control, which uses the product of the error (the difference between the current and target distances) and Kp to estimate a pwm value, as per the equation: error * Kp. With the maximum pwm signal duty cycle set at 255 and the error at 3000 mm, I initially approximated Kp as 255/400 ≈ 0.6375, indicating that adjustments should be along with this scale of magnitude. After fine-tuning, Kp was finalized at 0.3, closely matching the anticipated range. The decrement in Kp value aimed to provide the car with a more gental thrust to move towards the target. With Kp alone integrated, the stunt car's motion, as depicted in the video, was observed.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/XpttTvVY76w" title="Kp = 0.3" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            
                            <h4 class="mb-0">Integral gain</h4>
                            <p>Following the adjustment of Kp, I incorporated the Ki parameter to address the steady-state error and mitigate the oscillation issue. The integral term consists of the sum of Ki times the product of the distance error and its sampling period, leading to an increasing integrated value over time. I initiated Ki at a significantly lower value than Kp, setting it at 0.02 to cautiously approach the integration effect.
                                However, through testing, it became apparent that Ki needed to be adjusted to a much higher value of 0.05 to effectively counteract the steady-state error. To prevent the integral term from becoming excessively large, I implemented a clamp on the error accumulator. Recognizing that the robot starts a considerable distance from the equilibrium point, I aimed to prevent excessive error accumulation. Therefore, I set the error accumulator clamp at approximately 1000mm, facilitating a smoother approach to equilibrium and easier correction of the car's trajectory.
                            </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/9khJhyMkpso" title="Ki = 0.05" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <h4 class="mb-0">Integrator wind-up</h4>
                            <p>When the car remains stationary and the error is non-zero, the integral term will persistently accumulate. This causes the integral term's contribution to the PWM signal to increase until the motor reaches saturation. Beyond this point, the integral term continues to grow, surpassing the saturation level of the motor. It will start to decrease only when the car moves past the set point or the target distance. </p>
                            <br>
                            <p>These are the conditions under which I prevent the integrator from accumulating further value:
                                First, I halt the increase of the integral term or stop its accumulation when the controller output is saturated, which I set max 40 duty cycles from itegral part, to prevent the integral term from increasing further.
                                Second, as observed from the graph "All data over time" above, the integral part (represented by the orange line), which is the product of the integral gain (Ki) and the accumulated distance error in this lab, continues to increase until the error becomes negative. Therefore, I prevent the integrator from accumulating when the controller output's sign matches the error's sign. In other words, as soon as the error changes sign, I release the clamp on the integrator term, allowing it to decrease immediately. This approach helps to limit overshoot.</p>
                            <h4 class="mb-0">Differential gain</h4>
                            <p>As demonstrated in the previous video, the stunt car exhibited slight overshooting, prompting the introduction of the Kd parameter. Kd, applied within the derivative term of the PID controller, anticipates future changes in error. When the error decreases rapidly, its derivative becomes significantly negative, leading the derivative term to counteract the proportional and integral terms by reducing motor speed. Kd's application involves it being multiplied by the change rate between consecutive distance measurements.
                                Initially, I set Kd to 10. However, subsequent observations indicated that this differential gain was insufficient to effectively counterbalance the contributions of the proportional and integral gains, as the car continued to overshoot its target. </p>
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/Ol2U3PpHuqc" title="Kd = 10" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p> To refine the controller's performance, I incrementally adjusted Kd by increments of 10, ultimately finding that a Kd value of 60 enabled the stunt car to move smoothly and stop in alignment with my expectations, effectively minimizing overshoot and enhancing control precision.</p>                   
                            <iframe width="auto" height="auto" src="https://youtube.com/embed/rz3VzCsjSrs" title="Kd = 60" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                            <p>However, the car was slightly jittering while it was running and even after it stopped. The differential term is relatively challenging to handle, so I started to graphing the contributions from P, I, D terms to the PWM duty cycles control.  The entire differential term was calculated based on the error difference, which involves subtracting the previous error from the current distance error and then dividing by the elapsed time. The screenshot below illustrates how the PWM duty cycle changes as the PID controller contributes. The spike data results from the contribution of the D term. </p>
                            <img src="Imgs_lab5/nearby_two_erros.png" alt="two nearby errors monitored from D terms" style="width: 40vw; height: 20vw;">
                            <p>I suspected there could be a sudden change in the error, causing the D term to approach infinity due to division which is shown as spike. To address this, I began debugging by calculating the slope or the rate of error change. This was done by taking two sets of error data spaced at two different time points and dividing by the total amount of time elapsed.</p>
                            <img src="Imgs_lab5/data_furtheraway.png" alt="two errors further away monitored from D terms" style="width: 40vw; height: 20vw;">
                            <p>As shown in the screenshot, the spike problem has been mitigated, though it still exists. I adjusted the Kd parameter to 1 and conducted multiple tests, incrementally increasing Kd by 1 each time. When Kd reached 3, the resulting graph, as shown below, suggests that the issue I encountered earlier was due to an improper Kd parameter setting.</p>
                            <img src="Imgs_lab5/way_smaller_d.png" alt="with relatively nicer d" style="width: 40vw; height: 20vw;">
                            
                            <h4 class="mb-0">Sampling Time for PID control sending PWM signal</h4>
                            <p>The screenshot below displays the time difference measured at each iteration of the main loop. The average execution time of the main loop is 0.03 seconds.</p>
                            <img src="Imgs_lab5/PID_time.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                            
                            <p>The screenshot below shows the time period each time the TOF sensor measures a new distance. The average time it takes for the TOF sensor to collect data is 0.1 seconds.</p>
                            <img src="Imgs_lab5/TOF_time.png" alt="code to run one side" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
                    <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                        <div class="flex-grow-1">
                            <h3 class="mb-0">Extrapolation</h3>
                            <p>As illustrated by the error graph below, it is evident that the error updates slowly. This delay is primarily because the TOF sensor takes longer to collect a new data measurement. As discussed in the sampling time section above, the TOF sensor processing the measurement takes longer than the PID controller takes to update the PWM duty cycle. Consequently, given that a moving car might collide with an obstacle before receiving an updated error measurement from the TOF sensor, extrapolation could prove to be very beneficial.</p>
                            <img src="Imgs_lab5/error.png" alt="errors being stalled" style="width: 40vw; height: 20vw;">
                     
                            <p>Using the linear interpolation mathematical equation below, the data for a point on the graph can be obtained by calculating from two known data points.</p>
                            <img src="Imgs_lab5/interpolation_fomula.png" alt="linear intrapolation formula" style="width: 40vw; height: 20vw;">
                            <p>Therefore, I selected two data points obtained earlier and used them to calculate the subsequent distance error. This error is then used to adjust the Proportional, Integral, and Derivative (PID) terms, affecting the PWM duty cycle. Subsequently, this adjustment influences the car's speed and its distance to the target.</p>
                            <p>The code implemented for the logic is as the pseudocode described below: </p>
                  
                            <code>
                                <p> if (distanceSensor.checkForDataReady()) {</p>
                                <p style="margin-left: 2vw;">    intermediate_distance = distanceSensor.getDistance();</p>
                                <p style="margin-left: 2vw;">       data_obtained_time = millis();</p>
                                <p>}</p>
                                <p>else {</p>
                                <p style="margin-left: 2vw;">intermediate_distance = intermediate_distance + (current_time - data_obtained_time) * speed;</p>
                                <p>}</p>
                            </code>
                     
                            <p>As shown in the screenshot below, after extrapolation predicts the unknown data points while the TOF sensor's data is not ready, the distance error updates much more frequently, and the PWM signals used to control the car become more accurate.</p>
                            <img src="Imgs_lab5/extrapolation.png" alt="data points after extrapolation" style="width: 40vw; height: 20vw;">
                        </div>
                    </div>
            </section>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
